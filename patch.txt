diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml
new file mode 100644
index 0000000..79251f5
--- /dev/null
+++ b/.github/workflows/rust.yml
@@ -0,0 +1,22 @@
+name: Rust
+
+on:
+  push:
+    branches: [ main ]
+  pull_request:
+    branches: [ main ]
+
+env:
+  CARGO_TERM_COLOR: always
+
+jobs:
+  build:
+
+    runs-on: ubuntu-latest
+
+    steps:
+    - uses: actions/checkout@v3
+    - name: Build
+      run: cargo build --verbose
+    - name: Run tests
+      run: cargo test --verbose
diff --git a/.gitignore b/.gitignore
index d72f2d3..ad1deb9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,5 @@
 /target
-*.txt
 *.iml
-.idea/
-.DS_Store
+/.idea
+
+nl.txt
\ No newline at end of file
diff --git a/Cargo.lock b/Cargo.lock
new file mode 100644
index 0000000..9506d07
--- /dev/null
+++ b/Cargo.lock
@@ -0,0 +1,30 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 3
+
+[[package]]
+name = "anyhow"
+version = "1.0.67"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7724808837b77f4b4de9d283820f9d98bcf496d5692934b857a2399d31ff22e6"
+
+[[package]]
+name = "more-asserts"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7843ec2de400bcbc6a6328c958dc38e5359da6e93e72e37bc5246bf1ae776389"
+
+[[package]]
+name = "rltk"
+version = "0.1.0"
+dependencies = [
+ "anyhow",
+ "more-asserts",
+ "unicode-segmentation",
+]
+
+[[package]]
+name = "unicode-segmentation"
+version = "1.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7e8820f5d777f6224dc4be3632222971ac30164d4a258d595640799554ebfd99"
diff --git a/Cargo.toml b/Cargo.toml
new file mode 100644
index 0000000..a52d734
--- /dev/null
+++ b/Cargo.toml
@@ -0,0 +1,16 @@
+[package]
+name = "rltk"
+version = "0.1.0"
+edition = "2021"
+
+[dependencies]
+unicode-segmentation = "1"
+anyhow = "1"
+#regex = "1"
+
+[dev-dependencies]
+more-asserts = "0.2.2"
+
+[[bin]]
+name = "count"
+path = "src/bin/count.rs"
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..2d89307
--- /dev/null
+++ b/README.md
@@ -0,0 +1,23 @@
+__RLTK__
+
+An attempt to manually port some of nltk to rust.
+
+from https://www.nltk.org/api/nltk.lm.html:
+
+_So as to avoid re-creating the text in memory, both train and vocab are lazy iterators. They are evaluated on demand at training time._
+
+rltk has the same philosophy: everything is done using iterators (on iterators) on string slices.
+
+Currently in it's infancy (but growing): 
+* rltk::lm::preprocessing::pad_both_ends
+* rltk::lm::preprocessing::padded_everygrams
+* rltk::util::pad_sequence
+* rltk::util::pad_sequence_left
+* rltk::util::pad_sequence_right
+* rltk::util::ngrams
+* rltk::util::bigrams 
+* rltk::util::trigrams
+* rltk::util::everygrams
+* rltk::util::flatten
+* rltk::metrics::distance::edit_distance
+
diff --git a/examples/lm.rs b/examples/lm.rs
new file mode 100644
index 0000000..11c7f50
--- /dev/null
+++ b/examples/lm.rs
@@ -0,0 +1,48 @@
+
+/// These examples are taken from
+/// https://www.nltk.org/api/nltk.lm.html
+fn main() {
+    let text = vec![vec!["a", "b", "c"], vec!["a", "c", "d", "c", "e", "f"]];
+
+    println!("bigrams of {:?}:", text[0]);
+    let bigrams = rltk::util::bigrams(text[0].iter());
+    print(bigrams);
+
+    println!("\npadding {:?}", text[0]);
+    let padded: Vec<&&str> = rltk::util::pad_sequence(text[0].iter(), true, &"<s>", true, &"</s>", 2).collect();
+    println!("{:?}", padded);
+
+    println!("\ncombining bigrams and padding");
+    let combined = rltk::util::bigrams(rltk::lm::preprocessing::pad_both_ends(text[0].iter(),2));
+    print(combined);
+
+    println!("\neverygrams:");
+    let padded_bigrams: Vec<&&str> = rltk::lm::preprocessing::pad_both_ends(text[0].iter(),2).collect();
+    println!("padded {:?}",padded_bigrams);
+    let everygrams = rltk::util::everygrams(padded_bigrams.into_iter(), 2);
+    print(everygrams);
+
+    print!("or the same with padded_everygrams: ");
+    let padded_everygrams = rltk::lm::preprocessing::padded_everygrams(text[0].iter(),2);
+    print(padded_everygrams);
+
+
+    println!("\ncombining padding and flattening: {:?}:", text);
+    let flattened: Vec<&&str> = text.iter().map(|sent| rltk::lm::preprocessing::pad_both_ends(sent.iter(), 2)).flatten().collect();
+    println!("{:?}", flattened);
+
+
+}
+
+fn print<'a>(nested: impl Iterator<Item=impl Iterator<Item=&'a &'a str>>) {
+    print!("[");
+
+    for group in nested {
+        print!("[");
+        for word in group {
+            print!("{},", word);
+        }
+        print!("],");
+    }
+    println!("]");
+}
diff --git a/extra_cargo.toml b/extra_cargo.toml
deleted file mode 100644
index 5b1368c..0000000
--- a/extra_cargo.toml
+++ /dev/null
@@ -1,28 +0,0 @@
-[package]
-name = "tokenize"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-regex="1.5"
-lazy_static = "1"
-crossbeam-channel = "0.5"
-chrono = "0.4"
-unicode-segmentation = "1.9.0"
-
-#[profile.release]
-#debug = true
-
-[[bin]]
-name = "clean"
-path = "src/clean.rs"
-
-[[bin]]
-name = "substitute"
-path = "src/substitute.rs"
-
-[[bin]]
-name = "count"
-path = "src/count.rs"
\ No newline at end of file
diff --git a/extract b/extract
new file mode 100644
index 0000000..37a39e3
--- /dev/null
+++ b/extract
@@ -0,0 +1,500 @@
+Deze pagina is ontstaan omdat wij een verandering in de markt zagen. Enerzijds de mensen die graag eerst een kop koffie drinken, de klassieke manier en de snellere generatie die graag zo snel mogelijk op afstand een offerte ontvangt.
+Gevelreiniging en gevelrenovatie is een initiatief van GRS Gevelreiniging Service. Een bedrijf met jarenlange ervaring in gevelreiniging en gevelrenovatie. De klant centraal en kwaliteit voorop.
+Door hieronder zo volledig mogelijk te zijn in het invullen van uw offerte aanvraag kunnen onze gevelspecialisten een gedegen en volledige offerte aan u aanbieden voor gevelreiniging en gevelrenovatie. Na aanvraag ontvangt u zo spoedig mogelijk een dekkende offerte voor uw gestelde werkzaamheden.
+Kunt u aangeven binnen welke termijn u de werkzaamheden wilt hebben uitgevoerd:*
+Zo spoedig als redelijk mogelijk
+Type gevelrenovatie (selecteer hieronder wat van toepassing is):*
+Aantal vierkante meters of strekkende meter
+Bovenstaande zijn vierkante meters(m²)
+Om u direct een passende offerte te kunnen doen, heeft onze gevelspecialist een zo goed mogelijk beeld nodig van de situatie.
+Daarom vragen we u hieronder minimaal 1 en liefst meerdere foto's van de betreffende gevel(s) of gevelsituatie(s) toe te voegen.
+Heeft u naast renovatie van de oorspronkelijke gevel ook de wens een van onderstaande gevelverbeteringen uit te laten voeren en wilt u hiervoor offerte ontvangen (aanvinken indien van toepassing)
+Heeft u naast gevelreiniging van uw gevel ook de wens de gevel te laten impregneren of andere wensen en wilt u hiervoor offerte ontvangen (aanvinken indien van toepassing)?
+Bedankt voor het insturen van de specificaties, wij zullen u zo spoedig mogelijk een passende offerte sturen. Kwaliteit van onze werkzaamheden staat bovenaan, wij werken marktconform.
+Zijn er verder nog zaken die voor u de doorslag geven en u wilt terugzien in onze offerte?*
+Dit wil ik ook graag terug zien in de offerte:*
+
+Om te kunnen reageren op een huurwoning van De Woningzoeker moet u zich inschrijven via www.dewoningzoeker.nl. De inschrijfkosten bedragen €16,00. Hierna betaalt u jaarlijks €10,00.
+Ik ben mijn inlognaam en/of wachtwoord van De Woningzoeker kwijt. Wat kan ik doen?
+Bent u de inlognaam kwijt, neemt u dan contact met ons op (houdt uw BSN nummer bij de hand). Het wachtwoord kunt u zelf opvragen via www.dewoningzoeker.nl.
+Woonwagens en standplaatsen in Zwolle worden met voorrang toegewezen aan Zwolse woonwagenbewoners. Het aanbod komt via De Woningzoeker. U moet zelf actief reageren op dit aanbod. Hiervoor moet u ingeschreven staan bij www.dewoningzoeker.nl.
+Kan ik me inschrijven voor een nieuwbouwwoning in Zwolle?
+Ja, dat kan via www.dewoningzoeker.nl. U kunt bij uw inschrijving aangeven dat u alleen geïnteresseerd bent in nieuwbouwwoningen.
+Misschien is er iemand in uw directe omgeving die u hierbij kan helpen. Lukt dat niet, neemt u dan contact met ons op. Wij helpen u dan verder. Kijk op de contactpagina voor de contactmogelijkheden.
+Heeft u woningen direct te huur?
+Nee, wij hebben geen woningen die direct te huur zijn.
+Uw inschrijving en opgebouwde inschrijfduur zijn persoonsgebonden. Alleen als u getrouwd bent of een samenlevingscontract hebt, kan inschrijfduur overgedragen worden aan uw partner.
+Hoe lang duurt het voor ik een woning krijg in Zwolle?
+Dat is niet te voorspellen. Het hangt af van de wijk en het woningtype dat u zoekt. Op www.dewoningzoeker.nl ziet u bij de toegewezen woningen onder Aanbod met hoeveel inschrijftijd een woning is toegewezen.
+Ik sta ingeschreven als woningzoekende bij De Woningzoeker. Kan ik mijn punten overdoen aan iemand anders?
+Hiervoor heeft u uw persoonsgegevens en uw verzamelinkomen nodig. Dit staat op de inkomensverklaring of de aanslag van de Belastingdienst.
+Moet ik kinderen noemen bij mijn inschrijving bij De Woningzoeker?
+Ik wil een woning huren in Zwolle. Hoe werkt dat?
+Alle vrijkomende woningen van corporaties in Kampen en Zwolle worden aangeboden via De Woningzoeker. U kunt zich via www.dewoningzoeker.nl inschrijven als woningzoekende. De kosten voor een inschrijving zijn €16,00, de jaarlijkse verlenging kost €10,00. Inschrijven kan alleen via internet. Heeft u geen internet? Kijk in uw omgeving of iemand u kan helpen of bel met onze klantenservice 038 - 4680123.
+Ik ga samenwonen, maar sta alleen ingeschreven bij De Woningzoeker. Kan mijn partner bij mijn inschrijving gezet worden?
+Ja dit kan. Vult u hiervoor het aanvraagformulier inschrijving samenvoegen volledig in en lever dit formulier in bij één van de corporaties van De Woningzoeker of stuur het per email op. De contactgegevens vindt u op www.dewoningzoeker.nl
+Hoe weet ik mijn verzamelinkomen?
+U vindt uw verzamelinkomen op de inkomensverklaring of de aanslag van de Belastingdienst. Gaat u met meerdere personen verhuizen? Tel dan van alle meeverhuizenden het verzamelinkomen op. Het inkomen van kinderen telt niet mee.
+Ik sta onder bewind, hoe regel ik mijn inschrijving bij De Woningzoeker?
+Uw bewindvoerder kan hiervoor contact opnemen met een van de corporaties die bij De Woningzoeker zijn aangesloten.
+Vervalt mijn inschrijving bij De Woningzoeker als ik niks van me laat horen als jullie mij een woning aanbieden?
+Nee, uw inschrijving vervalt niet. Uw inschrijving kan wel geblokkeerd worden. Ga voor meer informatie naar www.dewoningzoeker.nl
+Wij staan samen ingeschreven bij De Woningzoeker, maar we gaan uit elkaar. Wie mag de inschrijving houden?
+Als eerst gecondoleerd. U vult het formulier 'Wijziging i.v.m. overlijden partner' in dat op de website www.dewoningzoeker.nl staat. Stuur het formulier, samen met een kopie van de overlijdensakte, aan ons op. Dit kan via de post of e-mail.
+
+Alle hotels in Benodet, Frankrijk
+6, Avenue de l'Odet, Benodet, Finistere, 29950, Frankrijk
+Hotel aan de rivier in Benodet, met een restaurant
+Klassieke tweepersoonskamer, gedeeltelijk uitzicht op zee - Badkamer [9/48]
+Klassieke tweepersoonskamer, gedeeltelijk uitzicht op zee - Eten en drinken [18/48]
+Klassieke tweepersoonskamer, gedeeltelijk uitzicht op zee - Kamer [26/48]
+Klassieke tweepersoonskamer, gedeeltelijk uitzicht op zee - Uitzicht vanaf kamer [28/48]
+Driepersoonskamer - Roomservice - dineren [41/48]
+Eenpersoonskamer, gedeeltelijk uitzicht op zee - Kamer [46/48]
+Tweepersoonskamer, uitzicht op zee (Cosy) - Kamer [47/48]
+Tweepersoonskamer, uitzicht op zee (Cosy) - Uitgelichte afbeelding[1/48]
+9 - Grand Hôtel Benodet Abbatiale, Benodet, Klassieke tweepersoonskamer, gedeeltelijk uitzicht op zee, Badkamer
+18 - Grand Hôtel Benodet Abbatiale, Benodet, Klassieke tweepersoonskamer, gedeeltelijk uitzicht op zee, Eten en drinken
+28 - Grand Hôtel Benodet Abbatiale, Benodet, Klassieke tweepersoonskamer, gedeeltelijk uitzicht op zee, Uitzicht vanaf kamer
+Strand van Benodet - 9 min. lopen
+Eenpersoonskamer, gedeeltelijk uitzicht op zee
+Klassieke tweepersoonskamer, gedeeltelijk uitzicht op zee
+Tweepersoonskamer, uitzicht op zee (Cosy)
+In de buurt van Grand Hôtel Benodet Abbatiale
+Station Quimper - 21 min. rijden
+Station Concarneau - 30 min. rijden
+Station Rosporden - 32 min. rijden
+Abbatiale - Een restaurant aan het strand, met alleen ontbijt.
+
+Altijd Wat - Snoep verstandig, eet een appel? - 24-9-2010 - TVblik
+Altijd Wat - Snoep verstandig, eet een appel?
+/ Snoep verstandig, eet een appel?
+Snoep verstandig, eet een appel. An apple a day keeps the doctor away. Of toch niet? Zijn appels wel zo gezond als wordt beweerd?
+De 24-jarige Turkse Birsen Basa heeft autisme. Ze vertelt hoe moeilijk het is om met deze afwijking in de Turkse cultuur te leven. Ze schreef er in het Turks een boek over. Nu komt haar boek 'Ik wil niet meer onzichtbaar zijn' ook in het Nederlands uit.
+Na de toespraak in New York, maakt Geert Wilders zich nu op voor een speech in Berlijn. Hoe reëel is de angst voor een islamitische 'tsunami'? In de Altijd Wat Wijzer de feiten en cijfers op een rijtje.
+Een persoonlijk gesprek met oud-minister Ronald Plasterk.
+Een minderheidskabinet: In Enkhuizen hebben ze al ervaring met een minderheidscollege.
+In de rubriek 'Zing, vecht, huil': tuintherapeute Annette Beerens: zij helpt mensen te herstellen van een burn-out of een psychose.
+Deze uitzending van het programma Altijd Wat met de titel Snoep verstandig, eet een appel? is uitgezonden op vrijdag 24 september door de NCRV. Te gast waren Bas Haring, Herman Vuijsje, Naema Tahir, Peter-Paul Verbeek, Ronald Plasterk en Stine Jensen. De presentatie was in handen van Ghislaine Plag.
+Altijd Wat Snoep verstandig, eet een appel?
+
+Veilig online met onze snelle servers in Nederlandse datacentra.
+Geen zorgen, altijd de nieuwste software en updates.
+Kies de optie die het beste bij je past. Flexibel en schaalbaar.
+Veilig ondernemen op snelle servers tegen lage kosten
+Optimaal schaalbaar en geen technische kennis nodig! Met een Managed Hosting oplossing hoef je je niet druk te maken om het serverbeheer. De serveromgeving wordt al naar gelang de wensen continu gemonitord en voorzien van de laatste updates voor Linux en Plesk. Behalve het onderhoud van de server kunnen wij ook zorg dragen voor het onderhoud van de website zelf.
+(WordPress) websites zijn door hun modulaire structuur (plugins) vaker aan updates toe dan een een statische HTML website, het is goed om te weten dat wij jarenlange ervaring hebben en je website altijd in topconditie houden.
+Je kunt ervoor kiezen alleen een hostingpakket af te nemen voor een enkele website(bijvoorbeeld WordPress hosting), maar ook voor meer complexe situaties hebben we flexibele schaalbare oplossingen. Denk aan een eigen Cloudserver waarbij je zelf, indien gewenst, wijzigingen kunt aanbrengen. Uiteraard voorzien van de modernste hard- en software.
+ICONS biedt diverse tools om ook na oplevering maximaal rendement te krijgen uit de opgeleverde website. Wij bieden onder meer;
+Meer informatie of een Managed Hosting offerte aanvragen? Vul het formulier in of neem contact op via (085) 303 39 20.
+Wil je meer informatie? Vul onderstaand formulier in of bel ons op (085) 303 39 20. Weet je nog niet wat voor soort hosting je nodig hebt? Geen probleem, we helpen je graag verder.
+
+Neem contact op met Zola Drive.
+Klinkt als geen ander. Serieus, we hebben geen idee, you be the judge.....
+Stuur een persoonlijk bericht naar Zola Drive
+Stuur een bericht naar Zola Drive en check de beschikbaarheid
+Zola Drive heeft nog geen reviews.
+Prijs inclusief reiskosten in Nederland.
+Zola Drive is een band uit Amsterdam. Zola Drive speelt muziek in de genres Rock, Blues & Pop. Zola Drive heeft sinds de inschrijving op 20/12/2016 in totaal 0 geverifieerde boekingen via Gigstarter binnengehaald.
+De muziek van Zola Drive klinkt als: geen ander. Serieus, we hebben geen idee, you be the judge...... Het repertoire van Zola Drive bestaat uit alleen eigen werk.
+Zola Drive hanteert een richtprijs van €700 - €1000 voor live optredens. Houd er rekening mee dat geluidsapparatuur, reisafstand en speelduur van invloed zullen zijn op de uiteindelijke gage maar schroom niet om het gesprek aan te gaan.
+
+“…De onderste 30% van een klantenbestand draagt structureel niet bij aan de winstgevendheid van een bedrijf…”
+### Waarom 30% van je klanten niets opleveren
+Gelukkig hoef je niet per definitie afscheid te nemen van de onderste 30% van je klantenbestand. Hoe lager je komt in de klantpiramide, hoe groter de kans is dat een klant meerdere leveranciers (jouw concurrenten dus) heeft voor producten of diensten die jouw organisatie ook verkoopt. En dat biedt kansen!
+### Durf te vragen… zodat je meer kunt verkopen
+Wil je praktische tips om meer verkoopkansen te creëren bij bestaande klanten? Lees het blog van Immelda. En schrijf je in voor het webinar verkoopkansen creëren
+Bestaande klanten kopen meer: laat jij geld liggen?
+
+Een AIS AtoN zendt een nauwkeurige positie uit en toont zo exact waar een lichtboei, een windturbine of een ander gevaar voor navigatie zich in het vaarwater bevindt.
+Een AIS AtoN kan ook worden gekoppeld aan bijv. een lamp in een vuurtoren of een batterij, zodat continue informatie over de lamp of de batterijstatus - op een eenvoudige en goedkope manier wordt weergegeven.
+Tevens kan een AIS AtoN worden gekoppeld aan een licht hetzij voor onderhoudsmonitoring van de lamp, of voor een meer geavanceerde status en configuratie van het licht (bijv. veranderende flash codes).
+Een AIS AtoN werkt op een solar powered accusysteem, ontworpen om voldoende stroom te leveren aan de AtoN en alle andere apparatuur op het platform, onder alle weersomstandigheden.
+Download het PDF-document voor volledige technische specificaties.
+
+De actuele pagina, het laatste heil.
+Is het mechanisme met de waangestalte uiteindelijk niet totaal mislukt?
+Doch slecht, kwaad, lelijk, groot en klein zijn geen absolute begrippen, omdat ze slechts wijzen op het ontbreken van volkomenheid. Het is een wetenschappelijke leugen deze beperking anders te willen omschrijven, een leugen die de maatschappij miljarden kost!
+Om dat te weten moet je kosmisch medewerker zijn,
+Wie de logos zoekt in een bepaalde vorm,.......
+In het Corpus Hippocraticum wordt nog steeds niets expliciet ...... door cognities te ontkoppelen van bepaalde emoties. De opmerkzaamheid van Jung is dus zeer terecht..........
+En slechts dwazen leggen overal een schil omheen, dan kunnen ze afzonderlijk in bezit nemen.
+Ja, over deze manipulatie zal U de wetenschap of de politiek niet horen vertellen!
+In de filosofie van "Het Zijn" kan er zowel een realisatie vanuit de makrokosmos zijn, maar ook realisatie vanuit de ziel, volgens deze realisatie's van Heraclitus en Parmenides, kan er zelfs niets absoluuts bestaan. Voor alle wezens is de natuur vast omlijnd en door voorgeschreven wetten beperkt.
+Toch is er de eigen verkiezing waaraan U bent overgeleverd, bijgevolg mag U de eigen wet stellen, die vrijheid is U gegeven! U heeft zelf de keuze ofwel hemels ofwel Aards te zijn.
+Niemand, maar dan ook niemand heeft het recht ons die keuze op te dringen.
+De Introspectie vormt in die zin een nooit wijkend besef van de beperktheid van het menselijk weten en kennen bij het handelen, wat we samen willen delen, moeten we ook kunnen verwoorden. Maar de census die de realiteit ons oplegt, ze blijft! Ze blijft ons laatste Heil.
+* Iemand heeft een bepaald idee, een gedachte, die hij aan een ander mens wil overdragen.
+*Aldus is de zelfgenezing onmogelijk tenzij het de wil van de ziel is! Heel gewoon moet er herkenning en erkenning komen van dit feit als intrinsieke wet, zodat de ziel opnieuw zijn oprechtheid naar voren kan brengen. Een andere keuze is er niet!
+Zo blijkt het steeds weer, mensen hebben hun medemensen nodig om zich te kunnen ontwikkelen tot mens. De mens is een sociaal wezen; .... hij wordt mens door interacties met andere mensen. Wat heeft een mens nu aan intermenselijke relaties, wat haalt hij eruit?
+* Deze relaties zijn vooral in de jeugd belangrijk, omdat het kind daardoor allerlei zaken leert; .... taal, normen, waarden. Zonder een voorbeeld (= de ander) is leren moeilijk of onmogelijk. De ander moet ook zekerheid bieden, angst bij falen voorkomen, en zo verder, Otto Selz baseerde zijn leer psychologie er op.
+Men heeft intermenselijke relaties nodig om het eigen ik te kunnen plaatsen in deze wereld. Men beoordeelt zichzelf in vergelijking met anderen. De menselijke attitude doet er zeker toe, en die moet je weten te ontwikkelen en op een plaats die daar geschikt voor is.
+* Intermenselijke relaties bieden de mogelijkheid tot het aftasten, toetsen van meningen en gevoelens.
+* Deze relaties bieden vriendschap, troost en de nodige hulp instanties bij angst, pijn en onzekerheid. Voor kinderen onderling is dat bijna een instantané dus directe zekerheid. Ten minste als ze goed opgevoed zijn, .......uit een goed nest komen, begrijpt U wel.
+* En dit schema geeft aan hoe het werkt; ....Alleen zo is er de kans dat we allerlei oneffenheden leren verwerken, dit deductieve denken en het niet denken is zelf een polariteit............ze is een kiezen voor het laatste heil.....
+De intermenselijke relaties zijn niet altijd en in alle opzichten even prettig. Er zijn ook nadelen en minder aangename aspecten; ....en daardoor ontwikkelt zich een zekere mate van twijfel!
+* Mensen kunnen elkaar controleren, zij kunnen nagaan of het gedrag van de ander wel past.
+* Mensen kunnen door intermenselijke relaties veel leed hebben; .... hopeloze liefde, verbroken verhoudingen en huwelijken, afwezige vrienden en familieleden.
+* Door relaties met anderen kan men overmatig afhankelijk worden, dat brengt de moederskinderen, en de neurotici vooral door het ontwikkelen van N.P.A., en dat maakt de bescheiden doener nogal eenzaam.
+Toch is er alle tijd voor het kind en de mens die tot eenheid van deze kosmos is gekomen in deze maatschappij. Want als je eenmaal zover bent dan is er een eigen weg.
+* Men kan zich soms belemmerd voelen: .... men heeft vele verplichtingen ten opzichte van anderen, waarmee men relaties heeft. Ja, zelfs bij oppervlakkige ontmoetingen blijkt hoezeer mensen rekening met elkaar houden en hun gedrag op anderen afstemmen.
+Wat dit schema laat zien heeft nogal consequentie voor de wetenschap, want de posities die de wetenschapsbeoefenaars onvermijdelijk innemen ten aanzien van de vragen die op de meest vitale manier menselijk gedrag raken, openbaren op de eerste plaats hun persoonlijke betrokkenheid daarin.
+Uiteindelijk zal hem in de komende periode dus duidelijk worden gemaakt dat hij heel veel heeft te leren, en zo hij dat niet doet kan hij veel beter vertrekken, als het Heil 's niveau hem niet interesseert.
+Als het heil van de mens voor hem geen doel op zich is, dan is de wetenschap puur slecht bezig. Men werkt dan met een puur verwrongen "Heden" .
+En Ja, en dan zitten we met de computer, Iedere computer zou toegerust moeten worden met schelle fluitjes, alarmbellen, onregelmatig repeterende sirenes die afgaan wanneer men voorspelbare teksten produceert. Beeldschermen zouden moeten opflikkeren en waarschuwingstekens moeten uitzenden, toetsenborden zouden opzettelijk verkeerde letters moeten typen.
+Gelukkig moet een calculerend onderdeel wel zijn eigen oprechtheid produceren. De waarheid is in yoga termen een wiskundige optelling kunnen maken. Verder is de computer als integer apparaat nooit gekomen, dat kon zelfs niet eens! Nog steeds ligt die bij de persoon die programmeert, en als de uitgever dan alleen maar denkt aan de centen?
+En zoals algemeen bekend veroorzaakt de verzadiging van de markt door een product, een daling van de omzet van dit product, en een gebrek aan algemeen vertrouwen. Om deze economische wet het hoofd te bieden zouden permanent nieuwe inzichten moeten worden ontwikkeld waaraan men weer plezier beleefd. Hier hebben we het dus weer over het spel, niet over enige werkelijkheid, maar ook het spel moet oprecht worden uitgespeeld! Anders gaan de deelnemers echt grommen!
+Het denken in "Dit Heden" is dus al het los komen te staan van het domein van de directe ervaring en zo zal het alleen maar geënsceneerde voorstellingen produceren. Wel leuk, maar de betrouwbaarheid van de computer mag U op allerlei terreinen in twijfel trekken.
+En met de wetenschap op de computer is het precies het zelfde als bij de seks industrie, de modellen zijn fictief aanwezig, de werkelijke modellen worden niet getoond! Lachen, gieren, brullen, niet waar!
+En ze weten alles over U, althans wat U wild horen en gebruiken, "Astronada" heeft U nooit van dat Spyware programma gehoord? Waar ze op inspelen moet U toch wel bekend zijn, nooit meer als Uw centen!
+En gaven ze U toch maar weer een miljoentje terug, maar dat doen ze niet! En zo blijven de bazen van de globale economie alleen onkwetsbaar en rijk.
+Om hier een oplossing voor te vinden heeft de wetenschap van God een tegenstrijdig Opperwezen gemaakt, dat zowel het goede als het kwade heeft bedacht om zijn "eigen liefde" beter uit te laten komen zodat men wel moet gaan geloven dat God zelf alles in scène heeft gezet. En dus volkomen los staat van zijn schepselen,.....dat hij het samenwerking 's partituur niet heeft bijgeleverd, hier in deze kosmos! .........
+En daarmee wordt de herintegratie niet de prijs van al het mogelijke positieve handelen!
+Maar we zitten in de situatie dat alle zielenherders en hun kudden proberen elkaar de loef af te steken, als het gaat om voor zichzelf geen schatten te verzamelen op aarde.
+Voor wie begrijpt dat uiteindelijk deze diepe lucratieve dissociatie het grote probleem van de mens is, en dat doet mij beslissen dat dit onderwerp nooit anders als een vrij onderwerp blijft. Ik zal hier nooit één letter schrijven om het brood, nog om meer dan dat!
+Het is een volkomen zandweg waarlangs het Manna uit de Hemelen staat.
+En wil je haar tegenkomen moet je eerst de hemelpoort gepasseerd zijn, maar die stond altijd al open.
+Hun grondregel is en blijft de gewraakte theorie. Want ze kunnen niets aan de oprechte praktijk koppelen.
+Er is een gewraakte theorie " m = m (t) ", zodra hij gesteld was, werd elke geënsceneerde bende mogelijk, ieder kon volgens de wetenschap daarna belogen worden, ......de m werd niet de gecontroleerde werkelijkheid , zoals het kon vanuit de QED!
+Wie uit deze bende wil nog enig heil verwachten?
+En dan volgt het roemruchte pilletje (drug) om de gevolgen enigszins te verzachten. Maar de hele wereld is er onderhand al van vergeven, vergiftigd zoals je het noemt! Dat is dus totaal geen oplossing meer. Vroeger (in de middeleeuwen) gooide het oordelende volk iedereen op de brandstapel, nu geeft het oordelende volk iedereen maar een pilletje.
+De werkelijke en oprechte participatie van iedereen, zodra die leverbaar is, staan we in een volkomen andere maatschappij. Alleen zo is deze maatschappij, met de miljarden Single-denkers en dwazen, te veranderen.
+Herinnering is uitsluitend het resultaat van die activiteit die voortvloeit uit achtergebleven indrukken, en komen geensinds voort uit een wetenschappelijke, noch politieke waan!
+De bijzondere neiging van het brein die vergezeld wordt door de actieve wens het zelf te kunnen, die leidt tot de vereniging met de Eén, en in het Oosten noemen ze dat yoga..........
+Daar bij kan je de gedachte ontwikkelen; ..... "zie hoe volmaakt ik ben en dan zal die bewuste volmaaktheid je gelukzaligheid zijn." En dat is wel degelijk de gelukzaligheid waar geen wetenschapper noch politicus zich op kan beroepen!
+Maar de werkelijke zichtbaarheid moeten we missen, ........Slecht de yoga onderkent de transitie van de ene werkelijkheid naar de andere. Ze mag van mij ook "Het licht-werk" genoemd worden. Dit stukje tekst is in oorsprong van twee trouwe lichtwerkers ............ze zijn de Wereld net zo trouw als ik.
+Vanuit het nu zijn er talloze mogelijke wegen, eindeloos veel mogelijke toekomsten. Op basis van het verleden kunnen we zeggen dat de ene waarschijnlijker is dan de ander, maar de keuze is aan jou. Het is jouw keuze of jij je verleden bepalend laat zijn voor jouw toekomst.
+Voorspellingen zijn altijd gebaseerd op waarschijnlijkheden. Waarschijnlijkheden worden berekend op basis van het verleden. Maar het is echt essentieel voor de mens dat hij kan breken met zijn verleden.
+Een mens kan veranderen. Hij kan zichzelf herscheppen. Dit is een goddelijke eigenschap: het vermogen om te scheppen uit het niets. Vergeet nooit dat dit goddelijke vermogen hoort tot de essentie van wie je bent. Als wij dus spreken van een overgangstijd, vergeet dan alsjeblieft niet dat jij meester bent over jouw werkelijkheid, altijd.
+In de loop van eeuwen ( Descartes tot heden) hebben heel veel van die ontaarde wiskundigen gehad, ik noem ze maar oneindig dwaas
+De transformatie functie is de enige werkelijke aanwijzing die oneindig is.
+En zonder deze transformatie komen wij als partners nooit dichter bij elkaar. En deze kans is er voor allen, voor iedereen!
+Nietzsche heeft volkomen gelijk!
+Geen enkel intellectueel onderzoek kan wat opleveren. De comparatieve filosofie zal nooit wat opleveren! De hele wijsbegeerte is beperkt, ....ze geeft geen oplossing, je ziet alleen de uitgebreidheid die de schepping heet. Al het narcisme, perfectionisme, en zijn arrogantie is vergeefs, ....het is een uitstalling van onwijsheid en domheid. Vooral op de ogenblikken dat het om de wezenlijke communicatie gaat. Er is nauwelijks een antwoord op te vinden als je niet van elkaar houd!
+We staan met alles wat we hebben voor hem. Maar het is niet nodig ook maar ergens bang voor te zijn!
+Er is geen maatschappij met echte wezens die zonder het wezenlijke kan; ....dat maakt dat elk axioma juist gedefinieerd moet zijn, anders hebben we het niet over iets wezenlijk's! Dan is er geen enkele Heil 's werking te verwachten!
+Als we kijken naar het axioma van Richard Feynman, dan mogen we niets van de intellectuele dwazen verwachten. Wat de mens tot de transformatie aanzet heeft Annie ook prima omschreven. Want men wordt aangetrokken tot een wijze van doen, die men voor zichzelf niet bezit, maar men ducht ook weer de consequenties van het tegenovergestelde. Zo diep ligt alles van dit doen in deze materialistische maatschappij begraven.
+Ernst Mach vertelt het ons in zijn juiste proportie; ...."Every thinker returns to the general point of view of mankind". Is dat nu echt zo'n zware lijdensweg? Bovendien vertelt Ernst Mach ons zo hoe hij tot zijn eigen presteren is gekomen, en zijn presteren was en blijft gigantisch!
+De werkelijke en oprechte participatie van iedereen, zodra die leverbaar is, staan we in een volkomen andere maatschappij. Alleen zo is deze maatschappij, met de miljarden Single-denkers en dwazen, te veranderen. De huidige mensheid danst vol op in de wereld die haar aangeleerd is, maar het is bepaald geen vreugde dans meer!
+Annie Besant vertelt U iets wat van gelijke aard is; ....
+en ik kan dat sinds mijn geboorte ervaren!
+Maar in feiten is deze theorie een dissociatie,
+om rechtstreeks aan gelden te komen,
+Ernst Mach vertelde het al eerder!
+Als dit geen bewijs is dat de wetenschap en de genetica totaal mis tast, begrijp ik het niet meer, en dan weet ik zeker dat wetenschappers oplichters zijn! Maar het echte licht is ver van hen. En zeer onterecht weten ze de twee-eenheid van De Geest en de Genade naast zich neer te leggen! Ze is nu algemeen herkend en erkend.
+Enige aanvaarding van uniciteit als wetenschappelijk begrip is nog steeds niet bespreekbaar nog plaatsbaar in enig menselijk brein. Men wil niets begrijpen van het laatste Heil wat op de mens wacht.
+Deze bewijzen zijn ook rechtstreeks te beschouwen door hun puntmassa M als een transponder te bezien . Want voor een puntmassa in een conservatieve energiepotentiaal is de Lagrange-functie het verschil tussen kinetisch en potentiële energie.
+En ik weet het ook te bewijzen!
+Lees dit goed, lk zeg dat U het ook kan, maar.........hoogstens....
+Ook het laatste heil zal voor U ontsloten worden ........
+Dat alles verloren gaat in de strijd om de begeerte, zal U daar bij wel weten.
+ze beheerst daarbij onze cultuur.
+De wetenden zijn te gering in aantal..........
+De mond is vol van vooruitgang en modernisering.
+Leven het straalvliegtuig, de TV en de computer, en daar bij de atoombom nog ook.
+Wat baat het ons, als we steeds ontevreden zijn?
+We weten niet eens meer waar we onze vakantie veilig kunnen doorbrengen.
+Hoe alles wat in scene gebracht is, veilig te maken is.
+De etterbulten en zweren in onze cultuur zijn niet meer te behandelen.
+Welke pil, welke zalf, wie wil onze manieren in werkelijke vereniging,
+Zijn dat echt zij, de heren die alles uit hun laboratoria,
+weten om te zetten in het slijk der Aarde?
+Of zijn dat toch die genen die aanmatiging van het brein,
+Het is de Goden een eren zaak, een zaak te verbergen,
+met de ootmoedige is de wijsheid.
+Dat verteld ons, de wijsheid behoort aan degenen,
+die de aanmatiging van het brein heeft overwonnen!
+Geen ding gaat in het universum verloren,
+zelfs niet de ademtocht uit onze mond.
+Alle dingen hebben een plaats en een bestemming.
+Tot de voltooiing van zijn werken.
+Er verzinkt niets in het niet, zelfs niet de woorden en de stem,
+alles heeft zijn plaats en zijn bestemming.
+De op Aarde levende wezens zeggen dat God is in den Hoge,
+terwijl de Engelen in de Hemel zeggen dat God op Aarde is.
+En het zal ons steeds duidelijker worden,
+Want toch, heel het deductieve denken kan leiden tot het herontdekken,
+Dientengevolge is de meta-fysica een leer die ontkennend aandoet.
+Ze is een zoeken naar onbeperktheid, tijdloosheid, ruimteloosheid, en niet denken.
+Maar de christelijke analogie is een rationele vergelijking, aangaande de begrippen ; ....
+Dat maakt de openbaring niet het zelfde als de metafysische ervaring,
+Maar de openbaring is de werkelijke aanzet tot de metafysische.
+Want als noch is er dan de regel van auto-topie, .......
+Indien iemand het onzichtbare wil kennen,
+dan moet je wel een open oog voor het zichtbare hebben!
+Van wat de menselijke wereld is, daar hangt zijn verschijningsvorm van zijn Geloof af.
+Wat wij als wereldse mens het eerste als goddelijke openbaring noemen,
+dat is de absolute verschijningsvorm van al wat is!
+Ze is de Bron van alle vormen en denkbeelden;
+Wordt het U gegeven dan is het voor U,
+Dank zij de loodzware neolithische last.
+Het volle begrip is te vinden in U zelf.
+Maar wees ook niet bang voor een mogelijke Hemelvaart.
+Noch om de intelligibele Engelen te ontmoeten.
+In feiten liggen hier de enige mogelijkheden om het geheel van de wetten, Functies, en structuren binnen ons DNA, die de volledige bewuste cognitieve structuur overheersen, het genius, te ontwikkelen.
+Als het doel van God het genius, dus intelligent leven is, dan zijn evolutionaire processen een hoogst onbetrouwbaar middel om dat te bereiken. Met ‘evolutionaire processen’ bedoel ik niet alleen biologische evolutie, maar ook kosmologische evolutie, chemische evolutie en planetaire evolutie.’
+Vergis U niet, de eigen innerlijke en uiterlijke mentale activiteit leidt door waarneming tot exacte kennis,
+daarbij funderen we de zekerheid van de feiten door deductie in het eigen algemene genetische proces.
+We kunnen het proces volgen door de openbaring van uit de kosmos.
+Ons onderwijs is thans toch steeds afgestemd op de versterking van de conditionering!
+Waarom maakt de mens deze dramatische keuze?
+Het drama is, dat het met de twee, openbaring
+en de metafysica alleen maar heel verwarrend wordt!
+Alleen wat ons werkelijk eigen is, daar in zijn we werkelijk één
+Dus door aan dit drama een einde te maken.......is er alleen maar hoop.
+iedere wezenlijke "herintegratie" van uit de bron ontbreekt,
+Deze keuze is foutief, omdat op netvlies zich het beeld vormt
+maar het oog heeft geen vermogen het beeld te vatten.
+Dat wat werkelijk waarneemt is brein.
+Die als ze niet waren verbonden met het brein,
+Zo kan men op geen enkele manier in een redelijke en liefelijke gemoedstoestand blijven.
+Het werkelijke bevatten is de taak van het brein.
+Daar nu is er de vereniging van het brein met de zintuigelijke organen,
+dat is hoe het leven zich vestigt........
+Zo niet dan heeft U een probleem, de waarneming door de zintuigen zonder vereniging,
+ze zal zich slechts als in begrensde fragmenten laten kennen........
+En de uitvinding van de theorie, volgens de Gek Karl Popper speelt er niet in mee......
+Voor de medische wetenschap is dit een ramp, want ook daar zal deze begrenzing zich laten gelden.
+Vele problemen zijn werkelijk niet onderkend, en de "emanciperende" mens is voor dit probleem resistent ,,,,
+Daar waar in het lichaam het zieke is, daar kan het gezonde per definitie niet zijn!
+Het is niets bijzonders dat het DNA "uit de Bocht vliegt" bij verkeert gebruik.
+Ook de Medische Wereld denkt dat ze wat weet, aan bewijzen en oplossingen,
+maar helaas, in deze geëmancipeerde wereld is het tegendeel nog altijd waar!
+Als je bedenkt dat slechts de ziel kennis kan dragen van o.a. het absoluut Goede, Schone en ware, en bovendien de woorden, slecht, kwaad, lelijk, groot en klein geen absolute begrippen zijn, omdat ze slechts wijzen op het ontbreken van volkomenheid, dan weet U hoe zwak de positie van de huidige mens is!
+Het ontbreken van de nodige volkomenheid, ze wordt verpatst tot on-vergelijkelijkheid, alsof er alsnog ergens een denk pad te volgens is! Maar de mens blijft toch lekker wat hij doet!
+Zij delen geen volks massa's op en compromitteren niet, noch gaan ze over op gehuichel en gekwezel.
+We hebben de resistente waanzinnige waan van de geëmancipeerde helemaal niet nodig.......
+Zo erken je de noodzakelijke psychologie niet.
+Zo wordt het onderscheid tussen realisatie
+en de inherente mogelijkheid nogal moeilijk!
+Psychologie als wetenschap kan en mag niet bevangen blijven in het alledaagse .....omdat het gedrag te herleiden zou zijn om tot een mechanisch model te worden, en dat is te gek om over na te denken.
+De mens zal in deze theoretische waan niet kunnen slagen.
+Het kind wordt de man of vrouw met het instinct voorgezet, en zij vinden alles genoeg waarmee ze zich mee kunnen compromitteren.
+Dus dat is het jammer genoeg niet!
+Het denken denkt dan niet meer iets; ...... het denkt nog alleen voor zichzelf. Ze heeft de voorbereiding voor de contemplatie niet! De conditionering op de wetenschappelijke waanzin is er slechts!
+De wetenschap heeft geen huisregels, ze woont ook doodgewoon op het normaal-vlak-Aarde.
+Als ze verzinsels van Popper bedoeld, dat zijn theorieën, met een theorie kan je geen theorie valideren noch populariseren. Dat is een hond die in zijn staart bijt, zou mijn leermeester zeggen.
+U heeft geen enkele kans ook maar één enkele correctie goed uit te voeren! Sterker nog, elke plaatselijke correctie helpt ze van de wal in de sloot!
+Een speciaal normaal-vlak in het effectieve referentiesysteem bestaat niet. Het effectief normaal-vlak is identiek aan het beitel-normaal-vlak … , in de wetenschap duurt het op deze manier nog wel een eeuw voor ze daar achter komt.
+En daar leeft dus de mens die ik een metaphysicum noem. Daar is de scriptie altijd gebaseerd op veronderstellingen die zijn van de metafysische natuur zichzelf, dus zoals zij is.
+Doch de meeste krankzinnige wetenschappers willen niet tot dit niveau terug gaan, anders is al hun gehuichel en gekwezel direct naar de maan!
+En toch heeft het hele andere gevolgen, .....zo als zij denken......
+Mocht U het niet begrijpen, hun compromitterende gekonkel kan dan wel gaan!
+Ja, het was zo; ........ze lieten steeds slechts een huid achter, daar kropen hun volgers in!
+De volgers knopen de huid als een jas aan, en gingen zo in het portaal van oneindig krankzinnige mannen curriculum staan, waar of niet waar het trok hen gewoon niet aan..........
+Ook de krankzinnige psychiater Freud liet ze allemaal maar begaan..........ze hadden toch zo'n mooi pak
+aan! En tenslotte was de onbewuste sexualiteit een belangrijk thema in de droomduiding van deze Freud, Die hij (de gek) uiteraard niet binnen een bewust wetenschappelijk curriculum brengen kon.
+Ik meende ook de Godheid woonde verre.
+Toen zag ik niets boven nedervaaren;
+Daar werd het liefelijk en zoet.
+Een geest, een hemels vlees en bloed,
+Maar zo, hoe moet zoiets nu aanslaan als je de "exogene" normering gebruikt, waar de doelbewuste grammatici en schoolmeesters maar ook de psycholoog zich onledig houden en een onzijdige flikker-houding aannemen, dan zal juist alles wat ons verder weg brengt van onze menselijkheid het punt zijn waar de schijnheiligheid zal worden gehanteerd, een evolutie probleem blijven, daar het zelf met eerste emanatie en zijn onderhoud wordt genegeerd, zo wordt slechts demorfie aangestuurd! Dat is wat we emancipatie noemen, en daar bij
+wordt niets binnen het innerlijk van de mens , het zelf, versterkt.
+In tegendeel de massa's worden mogelijk opgedeeld en daarmee gecompromiteerd, zo weet men een waardeloze elite te kweken, ........Het is geen methode om elkaar in ontologische zin te versterken, maar juist om elkaar te verzwakken.
+Het blijft een zoeken hoog boven maan en sterren, maar ......
+Het menselijk doen kan niet begrepen worden zonder de eerste emanatie, en het onderhoud moet haar versterking inhouden, gedrag' s verbetering is de score die we willen zien!
+Maar neen, de ontwikkeling van dwingende en invasieve lichamelijke stimulansen,
+om psychologische invloed te realiseren, op steeds subtielere manieren, heeft het zover gebracht!
+En nu staan we klaar om de afgrond in te vallen, ...........
+Toch, de ziel van een goed mens is een onneembare vesting. (Epiktetos)
+Het goede is altijd, elkaars weten te versterken, ........
+De glorificatie van het gevestigde is daarbij niets bijzonders!
+Daar in tegen is de gevestigde waan nodig om de wetenschappelijke onzin te vestigen.
+Psychologie is zo oud als de mensheid. Alleen heette ze vroeger mensenkennis. In spreekwoorden en gezegden leeft deze wijsheid van eeuwen verder. Uitspraken van wijzen werden tot gevleugelde woorden.
+Daarom hebben we deze oer-zielkunde vooropgesteld en hebben we trachten aan te tonen, hoe de wetenschap moeizaam opklimt om tot een scherpere formulering van de voor-wetenschappelijke begrippen te komen.
+Het is alleen volkomen mislukt, welke krankzinnige professor moeten we nu weer op onze kinderen
+loslaten. Hebben ze geen cel waar ze zelf goed genoeg in passen, om onze kinderen de vrijheid te geven?
+Want toch is het aan de mens het besef in te vangen van de eenheid met alle andere lichamen en zielen. En dat kan alleen maar op deze manier. Want enkel zo kan de wezenlijke deïficatie zich in elk mens voltrekken!
+De emanatie is namelijk het vertrekpunt van ieder mens, of je wil het niet over geboorte, leven, en dood hebben, en de schijn-heiligen van de wetenschap kletsen slechts over het DNA!
+Een mix aan dagelijkse ervaringen geeft een reeks aan foute verwachtingen (zwaardere voorwerpen vallen harder) en de vreemdheid van het gezichtspunt van natuur wetenschappers (wetten van Newton, concepten als vectoren versus getallen, enzovoorts) staan begrip vaak in de weg. Deze moeten gewoon door het doen en beleven weg gemasseerd worden. Zoals mijn luchtvaart-leraar mij deed onderkennen.
+De mix van onbegrip en rituele kennis en het leren van rituele antwoorden heeft nog steeds geen enkele zin. Daar de consequentie is dat de oorspronkelijke opvattingen en geloofsbelijdenissen weer naar boven komen bij contexten buiten de les.
+De Karnische les is als enige, wel eens waar beperkt, maar in zijn soort volledig en adequaat.
+De religieuze ervaring is er omdat er slechts fragmenten te verwoorden zijn van een Archaïsche wijsheid die het gemeenschappelijke bezit is van de mensheid.
+Wat er te permuteren valt in de natuur ( te veranderen , te verruilen, te verwisselen ) daar gaat de mens niet over. Dat is al bepaalt, dus wat we ons kunnen permitteren zonder dat iets echt onnatuurlijk lelijk wordt, dat zal je moeten ervaren met de zintuigen. Zo ontstaat er een religie, een Godsbesef dat geen behoefte heeft aan onbegrijpelijke, onnodige zaken die de dagelijkse werkelijkheid zouden ontstijgen.
+RNA is net zoals DNA een nucleïnezuur.
+Het wordt in het lichaam met zijn organismen gemaakt tijdens de transscriptie.
+En als nog, heeft het zin met het brein aan het werk te gaan zonder de wezenlijke vereniging met de zintuigen.
+Is er buiten dat dan nog die les, zo volledig en adequaat?
+Waar zijn de tastzin en levenszin werkelijk aan verbonden, is dat niet (heel normaal) het brein?
+En die onbegrijpelijke en onnodige zaken mogen ook niet opgelegd worden, de mens heeft zijn Geestelijke vrijheid nodig!
+Buiten dat, de krankzinnige wetenschap die een sequentie theorie heeft, ze valt om in haar keuze tussen kwaliteit en kwantiteit. Daarmee laat ze de werkelijke brein verbondenheid, zoals hij nog altijd is, vallen.
+Waar de waanzin van de universitaire wetenschap allang is verlopen, daar zal het regarderende verloop op de vorm en inhoud van de lerende zijn!
+Meer smaken zijn er niet, noch voor geen enkele autoriteit!
+Geboren met de mogelijkheden, is de mens geroepen te worden tot homo loguens, homo cogitans, homo faber, en homo ethicus te zijn!
+Dus ik constateer het maar, bij het logisch kosmisch denken hadden we al sinds Euclides extra brein-voorwaarden nodig! Euclides had de discrepantie tussen de fysica en de taal al bemerkt!
+Euclides heeft ons op deze waarheid gewezen en de Homo Universalis zal ons pas weer "goed" wijzen op het feit dat; ......de actualiteiten van het leven zich voegen naar de ontvankelijkheid van één ieders brein!
+En dat laatste Heil zal dan toch komen,.......
+Vanaf het jaar 1540 zijn we al in de zelfde context met onze religie bezig, en daarmee werd de ziel van allen verbonden, wat het belang van onderwijs en zielszorg buitengewoon doorzichtig maakt, leren verondersteld gedrags-verbetering zonder de bijprodukten leugen valsheid en bedrog! Dat is de kern van reformatie die bloeit onder ieder bewustzijn van elk mens, nog steeds!
+En een leerpsychologie die ons ook maar enigszins uit de brand helpt, is nog steeds verworpen! De levensvoorwaarden en levensvormen waar hier naar gestreefd wordt, ze zouden de krankzinnige wetenschap een worst wezen,.....en haar functionaliteit als instituut is tot een minimum geslonken, de vraag "waartoe leert de mens" wordt niet meer beantwoord!
+Denkt men er niet meer na over wat hen vandaag geopenbaard is, doch geen van de hemelse paleizen is het licht, noch de geesten, noch de zielen, noch enige vorm gevormd door de zintuigen is het licht.......
+er is beslist niets wat het denkvermogen kan begrijpen.
+Weet dat alles wat in de boven wereld bestaat, het licht der gedachten, oneindig is.......
+Wanneer gaat de wetenschap zijn eigen ziekte Nu eens onderzoeken en ontdekken? En de gevolgen daarvan, die we hier alle dagen zien! De drug, de atoombom en de steeds beter wordende wapens, en dan het hebbeding waar mee ze ons lekker weten te maken, je moet toch ergens voor strijden niet waar, al is het maar voor je grafmonument. Maar verder valt er niets te leren bij de dwazen, noch kijk men hoe een mens leert, de dwazen denken en leren alsof alles een theoretische afzonderlijkheid is.
+HET IS ECHTER EEN RADICAAL ARRANGEMENT IN DE PSYCHE, WAT ELKE GOEDE DIDAKTIEK HEEFT VERVLOEKT. DE KRANKZINNIGE GEVAARLIJKE MENS HEEFT ZO ZIJN DENKBEELDEN.
+EN ONZE UNIVERCITEITEN ZITTEN DAAR NOG VOL MEE OOK..........DE RAMP.......
+EN IN DE MASSAMEDIA BLIJKT ZE NIET TE STOPPEN.
+De homo discens, de lerende mens, men blijkt hem alleen maar af te willen stoppen.
+Deze ziekte van de grote negatie blijkt niet te stoppen, ze slaat overal in door, .......
+Want ook de reeds aanwezige verworvenheden van anderen blijken vreemdheden te zijn.
+Het is hoog tijd met deze krankzinnigheid te stoppen!
+Het is de grondslag van het menselijk zijn dat de mens voortdurend naar ontplooiing, naar vooruitgang, naar het geven van een steeds doelmatiger gedaante aan zijn levensvoorwaarden en levensvormen streeft.
+Dus dit houd al onder meer in, dat de mens van naturen op leren is aangewezen.
+Dit weten we al in zijn abstracte zin sinds het "Naturata en de Naturans" door Spinoza besproken werd.
+En nog vroeger weten we het in de enkele zin, sinds 1546 weten van Révész, dat we de reeds aanwezige voorwaarden op het terreinen van kennen en kunnen over moeten nemen. alvorens het bestaande te kunnen wijzigen.
+Alleen de huidige krankzinnige wetenschap kan het nog steeds niet!
+U bent Gek als U van deze bende nog wat zou verwachten!
+Want hun emancipatie brengt niets anders als het tegendeel.
+Wat men produceert, daarvoor is de huichelachtige spin-doctor alleen aan "het werk".
+De onbevangen wetenschappelijke beschouwing wordt altijd vertroebeld wanneer een opvatting, die geschikt is voor een beperkt doel, tot grondslag van alle onderzoek wordt gemaakt.
+U weet het misschien niet, maar het is het enige wat we willen weten.
+De wisselwerking tussen omgeving en innerlijke wereld door middel van de zintuigen zijn essentie!
+Het is altijd nodig dat je woorden los maakt van het fysieke, ik ben gesteld op het denkend "zijn"
+er is nog altijd te veel goeds op aarde,....
+Waarvan U mag weten dat het onderhouden moet worden,
+maar het is goeds waar de eerzuchtige mens blind voor moet blijven,
+Nog voor hij gaat denken dat een ambitieuze levenshouding gerechtvaardigd zou zijn.
+Want die is er beslist niet, er is alleen maar ruimte voor het plezier en de nodige contemplatie!
+Dit maak dat de enkeling, zonder enige werkelijke traditie het bijzonder moeilijk zal krijgen.
+Maar de beste traditie is toch wel de waarheid te vertellen!
+Voor hen die dit deden was het al eeuwen veel meer als een uitputtingsslag tussen lichaam en ziel; .....
+op de spanning tussen die twee, volgde voor hen die aan de menselijke zorg deden, een sprong naar de geest.
+Wie God zoekt in een bepaalde vorm, ....
+krijgt de vorm en mist God die in de vorm verborgen is.
+Maar wie God zoekt zonder oog voor vormen krijgt Hem zoals Hijzelf is,
+Pas daarin werden zij zichzelf en konden zij geloofwaardig tot de naaste gaan!
+Hun persoonlijke ellende krijgt zo altijd zijn universele zin,........
+En voor ons was er dus steeds weer dat louterende kunnen,
+wat alle groten der Aarde heeft gesierd,
+en zal blijven sieren........als broeders en strijders van de regenboog!
+Wij allemaal hebben het recht op deze wereld te aarden, met die kracht die in ons is, ......de laatste stap in onze evolutie komt er heel gewoon aan, .......wij allemaal zullen weten wat dat betekend, iemand overslaan doet ze niet!
+Niet de ongenuanceerde en onophoudelijke pogingen tot intimidatie die velen er op na houden!
+En zo gaat dat dus verder, je moet het gewoon lezen, ik kan geen beter advies geven.
+Het aha erlebnis, moet je in je zelf ervaren, en daarbij heb je eerlijke ware beelden nodig. Het onderwijs van nu is veel te intimiderend. Men heeft geen zin ook iets van het verkeerde bestaande te wijzigen.
+Maar wat Homo Universalis en Homo Discens zullen brengen, zal de Wereld heel gewoon weten te wijzigen.
+De beelddenkers courant ligt altijd voor mij, en de eerste vraag is daar, HOE DENK IK.
+Waar de waanzin van de wetenschap allang is verlopen, daar zal het regarderende verloop op de vorm en inhoud van de lerende zijn!
+Over mij kan je het niet hebben want ik ben gnosticus, mij word alles letterlijk toegeschoven. Omdat IEDER EERLIJK MENS ALLES MAG WETEN. Dat is dus de aanpak, die nodig is.......
+( NPA ) NARCISME, PERFECTIONISME, EN ARROGANTIE ZIJN VERGIF VOOR HET DENKEN. Weten is een kwestie van mentaliteit, je hart richten, fascinatie voor het onderwerp zorgt voor concentratie en contemplatie.
+Kreng Gerard 't Hooft hoort zelfs in het gekken-gesticht. Sinds wanneer zijn essentie en existentie uit elkaar geslagen. Om te beweren dat wij precies "apart" kunnen zijn? Gerard, geef daar nu eens antwoord op! Ach laat ik het maar geven, homo economisch is geneigd tot alle kwaad, en dat werd alle grondmotief!
+En aldus is ze zelden te vermijden.........doch ze is te vermijden. Maar alle autoriteit zal moeten worden gepasseerd, want ze kunnen en kennen nog steeds nagenoeg niets!
+Vanuit dat grondmotief zou de homo economicus (wij nagenoeg allemaal dus) rationeel en berekend handelen om het welbegrepen eigenbelang te dienen en veilig te stellen.
+Politici, beleidsmakers, bankiers en zo meer, ze baseren al jaren in toenemende mate het grote beleid op dat mens- en wereldbeeld; en zie het resultaat!
+Het merendeel van wat ze zouden willen zijn, kunnen ze in geen minuut meer zijn. .........De protagonist is een van de kernbegrippen in Psychodrama,.....van alle dag........Ja, de Wereld draait wel door........maar ze wordt één en al drama...........
+Er is niemand meer die zich de werkelijke eenheid wil realiseren.
+Wat in 1540 is begonnen, heel deze ontwikkeling moet nog eindigen!
+Wij kunnen deze aanklacht tegen deze wetenschap niet langer onder ons houden, of wilt U toch dat psychodrama, wat we het grote beleid noemen, tot het einde toe volhouden?
+Met het beeld van de statistiek, rechtstreeks door naar het rechtstreeks gewaande onmenselijke.
+Om je de waan van de historische menselijke ontwikkeling eigen te maken.........
+In Nederland aangelegd door het waan-bureau der statistiek, ........
+daar schijnt het allemaal niet waar te zijn, ze weten het nog niet eens een minuut, dat de actualiteit voor ieder mens het product is, wat volkomen afhankelijk is van de ontvankelijkheid van hun eigen brein.
+Mits de werkelijke geestelijke vrijheid hen is aangeleerd.
+Anders blijkt Uw geestelijke vrijheid U ontnomen! Hebben ze U de hemel uitgegooid.
+Het is hoog tijd dat "het grote beleid" wat anders wordt doorgevoerd ...........
+Heren flikker-volk, rot anders maar op, stop met al die mislukkingen ...........
+Sinds wanneer zullen deze beelden niet vergaan, en zijn de woorden niet onsterfelijk ...........
+maar op de drempel van het hart, daar kan alles tot ons komen, .......
+te midden van duisternis en onwetendheid.
+U moet het weten, zo kan het laatste heil er voor iedereen zijn.
+Zeer nadrukkelijk probeer ik U alles te vertellen, wat er aan "De hand is".......... Sommigen hebben de rede vervangen door een soort esthetische vervoering, anderen hebben hem opgeofferd aan een gedachteloos leven of een terugkeer naar een vermeende oerstaat.
+Zij die hun ondergang in gedachte hebben, ze mogen en kunnen hun gang gaan!
+Maar het lijkt mij niet zo gezond, de theologie en de wetenschap zijn de meest misdadige sekten, .........
+Mede daarom waarschuwden beide wijsgeren, ‘sterker dan enige denker voor hen, de toehoorders hun eigen uitspraken en geschriften niet klakkeloos voor waar aan te nemen, ook al lijken deze nog zo apodictisch.’ Dit blijkt net als in het verleden altijd de slechtste raadgeving,
+Zij blijken "De A-krankzinnige en gevaarlijke", ze weten niets van het meest wetenschappelijke axioma .....Het drama van de protagonisten meute is heel herkenbaar..........Altijd is het zo geweest, ......
+als de wet van het bedachte deeltje waar is; ..........dan is
+Mijn denken is zo ik Richard Feynman volg,
+Een eerlijkheid, een exegese, waarin ik alles kwijt kan.
+De rest is zo debiel als een loden deur..........
+De oprechte eenvoud is beslist geen resultaat van radeloosheid.
+Maar een plaats waar juist de menselijke reflectie een cruciale rol speelt.
+Zonder deze reflectie komen we de geboorte weeën van de Nieuwe Mens niet voorbij.
+En de statistiek is gewoon helemaal niets........
+Met het menselijke machtsvertoon, is er ook de oplegging van de onmacht ervaring.
+Hoe zal U zich met de gekken willen emanciperen?
+In de volledige krankzinnigheid en gevaarlijkheid!
+De oorzaak van de huidige factfree en sciencefree trend.
+Standpunten, geloofsovertuigingen en denksystemen verschaffen de mens een schijnzekerheid, die hem afhouden van het eigenlijke zijn. De vloek van de waan, de waan in alle geconditioneerdheid. De zonde val .........
+Hij zal zeer snel van het psychodrama van de krankzinnige en gevaarlijke weten los te komen.
+Slechts wie bereid is om niet alleen zijn vermeende gezag, maar zijn gehele menselijkheid restloos te offeren voor deze Manifestatie van Gods Wil, zal in dit Heilige Proces de door God Zelf daartoe bestemde knecht zijn, die de Mensheid ten zegen is. (J.W.Kaiser, Stichtingopenveldwerk.nl)
+Toch trachten ze zoiets bij ASML te imiteren, alleen het helpt het allemaal niet, met alle in scène gezette gegevens....die uit menselijke waanzin naar voren komen. Mooi om er aan verslaaft te geraken, meer niet.....de actualiteiten, dus ook de werkelijke, worden slechts toegelaten tot het ontvankelijke brein!
+Actualiteit en realiteit zijn toch wel wat anders sinds Spinoza, en bevatten zeker geen opgedrongen ecosysteem........waarmee de geestelijke gezondheid zeker wordt weggegeven aan een IT-Gek.
+Ja, het lijkt enkelen dus zelfs gepast dat ze het zelfs gaan hebben over de afzonderlijke schepping van ieder individuele soort of ding. Anderen wijzen erop dat energie behoud niet impliceert dat er niet langer ruimte is voor een God die sturend optrad in de materiële wereld, of voor een vrije wil tot uiting komend in lichamelijke handelingen. De schermutselingen zijn bijverschijnselen van het wetenschappelijk fysica-theologische proces, de nieuwe wetenschappelijke inzichten zijn specifieke geloofsartikelen. Ze zijn volgens alle heilige schrift nog geen veertigste waard van al het werkelijke goede handelen.
+En het Godendom van de heren van ASML wordt alleen door een oneindig gezwam bevestigd.
+Die veertigste klopt ook, de kwantumtheorie kan alleen in combinatie met een transponder nuttig worden gemaakt.
+Er is de keiharde uitwendige leefwereld enerzijds en een "Softe" bodemloze subject beleving anderzijds, en het geheel is de s Anibus. Maar daar zal de krankzinnige wetenschap wel nooit iets van willen begrijpen. Dat begrijpen hebben ze duizenden jaren geleden al definitief aan Pythagoras overgelaten!
+Het is ook véél te moeilijk en te spannend voor deze krankzinnige wetenschappelijke gekken. De tendentie die daar uit voort komt is dramatisch, ........... Waar het brein de wezenlijke transponders gebruikt, daar moet de computer het zonder transponder stellen,
+Correspondentie en opmerkingen zijn nog steeds mogelijk, ..... als U wat weet.. Lach om Uw inhoud, Lach om Uw bezit, want uit liefde zal het U ontnomen worden! Het paradoxale resultaat van de verdwijning van de polariteit 'innerlijkheid' en 'uiterlijkheid', is van alle dag!
+Ze beheerst deze wereld omdat het haar onbekend is dat de polariteit in de kosmos door antinomieën wordt overheerst.
+Zo regent het ergens en elders niet, zo is er een nominale realiteit, ook wel genoemd; de wezenlijke werkelijkheid.
+Zo is er slechts wetenschappelijke oplichting te bedrijven, met dergelijke apparatuur.
+Dus de agressie die het insigne van de oplichters opwerpt is helemaal niets waard.
+Net zo goed is het niet nodig om in het vreemde insigne van de dwaas Dijkgraaf te gaan geloven,
+Hij weet dat de nieuwe mens zonder de agressie slechts enige kans maak,
+(ze zijn dan negatief als ze de andere kant op gaan).
+Dan moet de som van al die stromen gelijk zijn aan nul.
+Nou, een stroom is een hoeveelheid elektronen die een kant op bewegen.
+Als in een knooppunt de stromen niet samen nul zouden zijn,
+dan zouden indat knooppunt de elektronen zich meer en meer gaan ophopen,
+of juist ontbreken. En dat kan natuurlijk niet alsmaar doorgaan;
+waar komt haar energie toch vandaan,
+zou de krankzinnige wetenschap haar hebben gemaakt?
+Net zo goed is het niet nodig om in het vreemde insigne.
+van de dwaas Dijkgraaf te gaan geloven, zij drukt die agressie slechts uit.
+Transponders kunnen actief of passief zijn.
+ze hebben een eigen energievoorziening toch echt nodig.
+De imbeciel Dijkgraaf weet zoiets niet.
+Hij is alleen A-krankzinnig en gevaarlijk,
+Hij werkt slechts met waanzin en imitatie,.......
+wat het aan de natuurlijke kosmische transponders ontbreekt.
+De Goddelijke combinatie van zender en ontvanger,
+mag van de krankzinnig niet bestaan!
+De eindtermen van zijn filosofie,
+Wat wij nalaten, zal in ons toch op toch autistische wijze voortgezet worden.
+En de nieuwe cultuur zal komen.........
+De sterkte van de Schepper zal verbluffend zijn!
+In mijn totale intuïtieve waarheid wordt mij gemeld, wat mij het laatste heil is, en dat is hemels!
+Ik zit dus met een toekomst wat het hemelse zal ontwikkelen,........en dat kan ook U overkomen.
+De geest wordt U ingeblazen, daardoor is er een vrije wil, die U ten goede of ten kwade kan gebruiken!
+Zo doende is het zeer onterecht de twee-eenheid van De Geest en de Genade naast zich neer te leggen!
+Ze is nu algemeen herkend en erkend. En om tot deze herkenning en erkenning te komen hebben we de Geestelijke vrijheid nodig!
+We hebben de vrije ruimte zoals Pythagoras hem wist te formuleren nodig, een ruimte die volkomen vrij is van antinomieën. Daar zijn de vergrovingen mogelijk. Daar is het ontwaken in het leven, dan ook een gave aan zichzelf.
+Dit U vertellen is de doelstelling die ik steeds heb meegekregen, zo lang ik hier was en ben.
+En buiten dat is er in het theater net als in de pest een soort vreemde zon;........
+een abnormaal intense glans waarin het voorkomt alsof al het moeilijke en onmogelijke plotseling ons normale element worden, ik zou het ook wel de kanker willen noemen!
+Hierin verschilt de religieuze mens het meest, zelfs zeer veel van de moralist. Deze ontkend het bestaan van alle psychofysische factoren die ons in de greephouden van onze instincten en drijfveren.
+De formulering is ;.... "De entropie van een 'universum' neemt toe bij elke proces dat hierin spontaan optreedt. De meest debiele aanname dat een proces "spontaan" kan optreden in dit "universum" is voor mij al een dialectische woordspeling die niet te begrijpen is. Dat heb je met de krankzinnige onafhankelijke academici, ze verzinnen van alles.
+En dat moet dan weer worden bevestigd door de popperrazzi media die zich in de media ophouden.
+En ze willen alles zo graag, ... zelfs Newton werd zo'n ezel. Waarom zal U vragen, wel ik weet met grote zekerheid dat de Newton er is in bepaalde aantallen, en de relatie tussen de hoeveelheid en het aantal is in de volgende bewoordingen uitgedrukt.
+Het hele begrip spontaan is al een farce, de Newton zoals wij hem gebruiken heeft al niets specifieks. Met als gevolg dat wij mensen de kwaliteit en de kwantiteit van ieder product zelf moeten beoordelen! In experiment! Wat en hoe er zich nu iets spontaan voor onze ogen tovert en heeft getoverd, dat moet U toch maar weer even uitleggen!
+binnen de natuur automatisch worden teruggebracht!
+We kunnen ons niet langer alles onder druk van de algemene geestesziekte laten begaan!
+Cultuur en genen delen dan immers zeker niet meer het zelfde succes.
+Ik laat mij niet ten onrechte toch noch door "Het Laatste Heil" inspireren, ziende de wereld problemen!
+Voor wie het wiskundig wil horen.
+Maar waarom zouden we moeten accepteren dat het chaos is, zo het komt?
+Onze schepper wil oplossingen, weet U wel, en dat elke dag weer!
+Laat de gemeenschap met rust, het is niet nodig dat er steeds weer een toestand van hysteresis en paranoia optreed in de gemeenschap! We kunnen ons niet langer alles onder druk van de algemene geestesziekte laten begaan!
+Deze samenleving houdt niet op te werken bij de huid, ....maar bestaat ook binnen de mensen die erin leven.
+De feitelijke, reële en actuele verbindingen vormen dus maar een deel van de fysische praktijk van een mens met zijn omgeving. Om zijn leven te begrijpen moeten de virtuele en intieme verhoudingen in de metafysische praktijk die hij bij zichzelf gaande houdt erbij bedacht worden.
+Onze Geestelijke vrijheid bestaat, hij moet alleen nog gerespecteerd worden!
+Daarna kunnen we ons allemaal de vragen van Jules Ruis stellen!
+Laat U dat laatste Heil niet ontnemen!
+Fishing in the genome-pond, is dit wat voor U
+De relatie/interactie tussen genen en memen.
+We onderscheiden binnen het menselijk functioneren 'genen' en 'memen'.
+Het resultaat van de wisselwerking tussen genen en memen uit zich in het ontstaan van 'gemen'.
+Deze gemen vormen de drijfveer voor menselijk handelen en gedrag.
+en dat resulteert in het ontstaan van gemen.
+Vragen die we aan de orde stellen zijn:
+Staan genen voor de natuur en memen voor de cultuur ?
+Staan genen voor het lichaam en memen voor de geest?
+Staan genen voor het leven en memen voor het licht? (Is er dan ook nog duisternis?)
+Of zijn genen en memen gewoon de keerzijden van dezelfde medaille: foto en film, deeltje en golf tegelijk?
+Beschikt elk organisme dan ook over een ziel?
+Is de ene ziel verbonden (religio) met alle andere zielen?
+Ontstaat op die manier een soort universele verbondenheid?
+Tenslotte vragen we naar de Verbondenheid in Ruimte en Tijd.
+Ieder mens kan zijn verslag doen in vrijheid, want wat je de Aarde aandoet doe je ook je zelf aan, maar daar houd het al bijna mee op. Waar is dan toch het begin van de weg?
+Is er een Universele Bestaans Wet (a Theory of Everything) die alles verbindt?
+Omvat die verbondenheid hetzelfde begrip als God, Allah, Jahweh, Boeddha of Tao.
+En zijn we daarmee weer aan het begin van de weg?
+Valt het punt alfa dan samen met het punt omega: het hier en nu van elke dag?
diff --git a/nl.dict b/nl.dict
new file mode 100644
index 0000000..e69de29
diff --git a/src/bin/count.rs b/src/bin/count.rs
new file mode 100644
index 0000000..1392404
--- /dev/null
+++ b/src/bin/count.rs
@@ -0,0 +1,3 @@
+fn main(){
+    rltk::pipelines::count();
+}
\ No newline at end of file
diff --git a/src/clean.rs b/src/clean.rs
deleted file mode 100644
index b5ffd6a..0000000
--- a/src/clean.rs
+++ /dev/null
@@ -1,117 +0,0 @@
-#![warn(clippy::all, clippy::pedantic)]
-
-use std::{env, io, process, thread};
-use std::collections::HashMap;
-use std::fs::File;
-use std::io::BufRead;
-use chrono::{DateTime, Local};
-use crossbeam_channel::bounded;
-use lazy_static::lazy_static;
-use unicode_segmentation::UnicodeSegmentation;
-
-use crate::worker::ThreadPool;
-
-mod worker;
-
-const BUFFER_SIZE: usize = 10_000;
-
-fn main() -> Result<(), io::Error> {
-    let args: Vec<String> = env::args().collect();
-    if args.len() < 2 {
-        eprintln!("Usage: clean [whitelist-filename] input-filename");
-        process::exit(-1);
-    }
-
-    let input_filename = if args.len() == 3 {
-        &args[2]
-    } else {
-        &args[1]
-    };
-
-    let start: DateTime<Local> = Local::now();
-
-    let file = File::open(input_filename)?;
-    let reader = io::BufReader::new(file);
-
-    let mut worker_pool = ThreadPool::new(4); // TODO turn into cmdline argument
-    let (merge_sender, merge_receiver) = bounded::<Option<Vec<String>>>(8);
-
-    {
-        thread::spawn(move || {
-            loop {
-                // handle Error case silently
-                let maybe_buffer = merge_receiver.recv().unwrap_or(None);
-                if let Some(clean_buffer) = maybe_buffer {
-                    for line in clean_buffer {
-                        println!("{}", line);
-                    }
-                } else {
-                    // None is the break signal (may be made nicer using enum)
-                    break;
-                }
-            }
-        });
-    }
-
-    let mut line_count = 0usize;
-    let mut buffer = Vec::with_capacity(BUFFER_SIZE);
-    for line in reader.lines().flatten() {
-        if line_count < BUFFER_SIZE {
-            buffer.push(line);
-            line_count += 1;
-        } else {
-            // multi producer, single consumer. So multiple senders, using clone
-            let merge_sender = merge_sender.clone();
-            worker_pool.execute(move || handle_line_buffer(buffer, &merge_sender));
-            buffer = Vec::with_capacity(BUFFER_SIZE);
-            line_count = 0;
-        }
-    }
-    // last, partially filled buffer
-    worker_pool.execute(move || handle_line_buffer(buffer, &merge_sender));
-
-    worker_pool.wait();
-
-    eprintln!("took {} seconds", Local::now().signed_duration_since(start));
-    Ok(())
-}
-
-fn handle_line_buffer(buffer: Vec<String>, sender: &crossbeam_channel::Sender<Option<Vec<String>>>) {
-    lazy_static! {
-        static ref args: Vec<String> = env::args().collect();
-        static ref w:Vec<String> = if args.len() == 3 {
-            let whitelist_filename = &args[1];
-                read_whitelist(whitelist_filename).unwrap()
-            } else {
-                read_std_whitelist().unwrap()
-        };
-        static ref WHITELIST:Vec<&'static str> = w.iter().map(|s| s.as_str()).collect::<Vec<&'static str>>();
-    }
-    let mut clean_buffer = vec![];
-    for line in buffer {
-        let mut clean_line = String::new();
-        line.graphemes(true).filter(|g| WHITELIST.contains(g)).for_each(|c| clean_line.push_str(c));
-        clean_buffer.push(clean_line);
-    }
-    sender.send(Some(clean_buffer)).unwrap();
-}
-
-fn read_whitelist(filename: &String) -> Result<Vec<String>, io::Error> {
-    let file = File::open(filename)?;
-    let reader = io::BufReader::new(file);
-    let mut whitelist = vec![];
-    for line in reader.lines().flatten() {
-        line.graphemes(true).for_each(|token| whitelist.push(token.to_owned()));
-    }
-
-    Ok(whitelist)
-}
-
-fn read_std_whitelist() -> Result<Vec<String>, io::Error> {
-    let whitelist_dat = include_str!("default_whitelist.dat");
-    let mut whitelist = vec![];
-
-    whitelist_dat.graphemes(true).for_each(|token| whitelist.push(token.to_owned()));
-
-    Ok(whitelist)
-}
\ No newline at end of file
diff --git a/src/count.rs b/src/count.rs
deleted file mode 100644
index 05b10a8..0000000
--- a/src/count.rs
+++ /dev/null
@@ -1,124 +0,0 @@
-#![warn(clippy::all, clippy::pedantic)]
-
-use std::{env, process};
-use std::collections::HashMap;
-use std::fs::File;
-use std::io::{self, BufRead};
-use std::io::Error;
-use std::sync::{Arc, Mutex};
-use std::thread;
-
-use chrono::prelude::*;
-use crossbeam_channel::bounded;
-
-use crate::worker::ThreadPool;
-
-mod worker;
-
-const BUFFER_SIZE: usize = 10_0;
-
-/// Creates counts for single words in a text (file). These can be used as preprocessing for (sub)word tokenization
-/// Writes the result to a new file.
-///
-/// removes all interpunction and special characters
-///
-/// Uses a fork-join pattern using 8 threads (can be changed in the code).
-///
-pub fn main() -> Result<(), Error> {
-    let args: Vec<String> = env::args().collect();
-    if args.len() < 2 {
-        eprintln!("Usage: tokenize [filename]");
-        process::exit(-1);
-    }
-
-    let input_filename = &args[1];
-    let start: DateTime<Local> = Local::now();
-
-    eprintln!("started at {:?}", start);
-    let file = File::open(input_filename)?;
-    let reader = io::BufReader::new(file);
-
-    // counter for determining if the buffer is full (and ready to be passed to a worker thread)
-    let mut line_count = 0usize;
-
-    let mut worker_pool = ThreadPool::new(4); // TODO turn into cmdline argument
-
-    // this is the end result before writing to file
-    let merge_counter = Arc::new(Mutex::new(HashMap::new()));
-
-    // bounded channel for sending intermediate results (counts for a single buffer) to the merger
-    // let (merge_sender, merge_receiver) = crossbeam_channel::bounded::<Option<HashMap<String, usize>>>(8); //#threads
-    let (merge_sender, merge_receiver) = bounded::<Option<HashMap<String, usize>>>(8);
-    // crossbeam_channel::bounded::<Option<HashMap<String, usize>>>(8); //#threads
-
-    // create new scope for the merge_counter clone
-    {
-        let merge_counter = Arc::clone(&merge_counter);
-        // create a single thread that waits for intermediate counts to process them in the overall result
-        thread::spawn(move || {
-            loop {
-                // handle Error case silently
-                let maybe_buffer = merge_receiver.recv().unwrap_or(None);
-                if let Some(counter) = maybe_buffer {
-                    // create a lock on the merge_counter (this is the only thread while processing). The main thread will read later
-                    let mut merge_counter = merge_counter.lock().unwrap();
-
-                    // update counts and discard intermediate result
-                    for (word, count) in counter {
-                        let entry = merge_counter.entry(word).or_insert(0);
-                        *entry += count;
-                    }
-                } else {
-                    // None is the break signal (may be made nicer using enum)
-                    break;
-                }
-            }
-        });
-    }
-
-    // read a file of text with line separators
-    // when the buffer is full, pass it to a handle_line_buffer function
-    let mut buffer = Vec::with_capacity(BUFFER_SIZE);
-    for line in reader.lines().flatten() {
-        if line_count < BUFFER_SIZE {
-            buffer.push(line);
-            line_count += 1;
-        } else {
-            // multi producer, single consumer. So multiple senders, using clone
-            let merge_sender = merge_sender.clone();
-            worker_pool.execute(move || handle_line_buffer(buffer, &merge_sender));
-            buffer = Vec::with_capacity(BUFFER_SIZE);
-            line_count = 0;
-        }
-    }
-    // last, partially filled buffer
-    worker_pool.execute(move || handle_line_buffer(buffer, &merge_sender));
-
-    // wait for processing to finish
-    worker_pool.wait();
-
-    for (word, count) in merge_counter.lock().unwrap().iter() {
-        // cutoff is 5 (inclusive min word count)
-        // TODO parametrize
-        if *count > 4 {
-            println!("{}: {}", word, count);
-        }
-    }
-
-    eprintln!("took {} seconds", Local::now().signed_duration_since(start));
-    Ok(())
-}
-
-fn handle_line_buffer(buffer: Vec<String>, sender: &crossbeam_channel::Sender<Option<HashMap<String, usize>>>) {
-    let mut counter = HashMap::new();
-
-    for line in buffer {
-        for word in line.split(&[' ', ',', '.', ';']) {
-            let count = counter.entry(word.to_lowercase().to_owned()).or_insert(0);
-            *count += 1;
-        }
-    }
-
-    sender.send(Some(counter)).unwrap();
-}
-
diff --git a/src/default_substitute.dat b/src/default_substitute.dat
deleted file mode 100644
index fcc9b73..0000000
--- a/src/default_substitute.dat
+++ /dev/null
@@ -1,10 +0,0 @@
-àáâäæãåāÀÁÂÄÆÃÅĀ:a
-èéêëēėęÈÉÊËĒĖĘ:e
-îïíīįìÎÏÍĪĮÌ:i
-ûüùúūÛÜÙÚŪ:u
-ôöòóœøōõÔÖÒÓŒØŌÕ:o
-çćčÇĆČ:c
-ÿŸ:y
-łŁ:l
-ñńÑŃ:n
-žźżŽŹŻ:z
\ No newline at end of file
diff --git a/src/default_whitelist.dat b/src/default_whitelist.dat
deleted file mode 100644
index c8749cd..0000000
--- a/src/default_whitelist.dat
+++ /dev/null
@@ -1,13 +0,0 @@
-abcdefghijklmnopqrstuvwxyz
-ABCDEFGHIJKLMNOPQRSTUVWXYZ
- .,;
-àáâäæãåāÀÁÂÄÆÃÅĀ
-èéêëēėęÈÉÊËĒĖĘ
-îïíīįìÎÏÍĪĮÌ
-ûüùúūÛÜÙÚŪ
-ôöòóœøōõÔÖÒÓŒØŌÕ
-çćčÇĆČ
-ÿŸ
-łŁ
-ñńÑŃ
-žźżŽŹŻ
\ No newline at end of file
diff --git a/src/lib.rs b/src/lib.rs
new file mode 100644
index 0000000..b9b99af
--- /dev/null
+++ b/src/lib.rs
@@ -0,0 +1,8 @@
+pub mod lm;
+pub mod util;
+pub mod metrics;
+pub mod mat;
+pub mod pipelines;
+
+#[cfg(test)]
+pub(crate) mod test;
diff --git a/src/lm/mle.rs b/src/lm/mle.rs
new file mode 100644
index 0000000..9b248d1
--- /dev/null
+++ b/src/lm/mle.rs
@@ -0,0 +1,106 @@
+use std::collections::BTreeMap;
+
+struct Vocabulary<'a> {
+    cutoff: usize,
+    counter: Counter<'a>,
+    unk_label: &'a str,
+}
+
+impl <'a>Vocabulary<'a> {
+    pub(crate) fn new(cutoff: usize) -> Self {
+        Self {
+            cutoff,
+            counter: Counter::new(),
+            unk_label: "<UNK>",
+        }
+    }
+
+    pub fn update_word(&mut self, word: &'a str) {
+        self.counter.update_word(word);
+    }
+
+    pub fn update_sentence(&mut self, sentence: impl Iterator<Item=&'a &'a str>) {
+        self.counter.update_sentence(sentence);
+    }
+
+    pub fn lookup_word(&self, word: &'a str) -> &str {
+        return if self.counter.get(word) > self.cutoff {
+            word
+        } else {
+            self.unk_label
+        };
+    }
+
+    pub(crate) fn lookup_sentence(&self, sentence: impl Iterator<Item=&'a &'a  str> + 'a) -> impl Iterator<Item=&'a str> + '_{
+        sentence.map(|word| if self.counter.get(word) > self.cutoff {
+            word
+        } else {
+            self.unk_label
+        })
+    }
+}
+
+struct Counter<'a> {
+    counts: BTreeMap<&'a str, usize>, //may just need hashmap, not sure yet, do we need ordered keys?
+}
+
+impl<'a> Counter<'a> {
+    pub(crate) fn new() -> Self {
+        Self {
+            counts: BTreeMap::new()
+        }
+    }
+
+    pub(crate) fn update_word(&mut self, word: &'a str) {
+        let count = self.counts.entry(word).or_insert(0);
+        *count += 1;
+    }
+
+    pub(crate) fn update_sentence(&mut self, sentence: impl Iterator<Item=&'a &'a str>) {
+        sentence.for_each(|word| self.update_word(word));
+    }
+
+    pub(crate) fn get(&self, word: &str) -> usize {
+        *self.counts.get(word).unwrap_or(&0)
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_lookup() {
+        let mut vocab = Vocabulary::new(1);
+        vocab.update_sentence(["a", "b", "c", "a", "b", "c"].iter());
+        let looked_up: Vec<&str> = vocab.lookup_sentence(["a", "b", "c"].iter()).collect();
+        assert_eq!(looked_up, vec!["a", "b", "c"]);
+        let looked_up: Vec<&str> = vocab.lookup_sentence(["Aliens", "from", "Mars"].iter()).collect();
+        assert_eq!(looked_up, vec!["<UNK>", "<UNK>", "<UNK>"]);
+    }
+
+    #[test]
+    fn test_lookup_below_cutoff() {
+        let mut vocab = Vocabulary::new(1);
+        vocab.update_sentence(["a", "b", "c"].iter());
+        let looked_up: Vec<&str> = vocab.lookup_sentence(["a", "b", "c"].iter()).collect();
+        assert_eq!(looked_up, vec!["<UNK>", "<UNK>", "<UNK>"]);
+    }
+
+    #[test]
+    fn test_count_words() {
+        let mut counter = Counter::new();
+        counter.update_word("a");
+
+        assert_eq!(counter.get("a"), 1);
+    }
+
+    #[test]
+    fn test_count_sentence() {
+        let mut counter = Counter::new();
+        counter.update_sentence(["a", "b", "a"].iter());
+
+        assert_eq!(counter.get("a"), 2);
+        assert_eq!(counter.get("b"), 1);
+    }
+}
\ No newline at end of file
diff --git a/src/lm/mod.rs b/src/lm/mod.rs
new file mode 100644
index 0000000..4447e47
--- /dev/null
+++ b/src/lm/mod.rs
@@ -0,0 +1,2 @@
+pub mod preprocessing;
+pub mod mle;
\ No newline at end of file
diff --git a/src/lm/preprocessing.rs b/src/lm/preprocessing.rs
new file mode 100644
index 0000000..58100f3
--- /dev/null
+++ b/src/lm/preprocessing.rs
@@ -0,0 +1,42 @@
+// use crate::util::flatten;
+
+/// Pads a sequence of words with defaults; prepends "<s>" and appends "<s>"
+///
+/// sentence: sequence of words, tokens, to pad, in the form of an Iterator of string slices.
+/// n: the n in n-grams; so for bigrams set to 2, etc
+pub fn pad_both_ends<'a>(text: impl Iterator<Item=&'a &'a str> + 'a, order: usize) -> impl Iterator<Item=&'a &'a str> {
+    crate::util::padding::Padder::new(Box::new(text), true, &"<s>", true, &"</s>", order)
+}
+
+pub fn padded_everygrams<'a>(sentence: impl Iterator<Item=&'a &'a str> + 'a, order: usize) -> impl Iterator<Item=Box<dyn Iterator<Item=&'a &'a str> + 'a>> + 'a  {
+    crate::util::everygrams(pad_both_ends(sentence, order), order)
+}
+
+// pub fn padded_everygram_pipeline<'a>(text: impl Iterator<Item=&'a &'a str> + 'a, order: usize) -> (impl Iterator<Item=&'a &'a str>){
+//     (text.map(|sent| crate::lm::preprocessing::pad_both_ends(sent), order)).flatten())//vocab
+// }
+
+#[cfg(test)]
+mod tests{
+
+    use super::*;
+
+    #[test]
+    fn test(){
+        let sentence = ["a","b", "c"];
+        let mut bigrams = padded_everygrams(sentence.iter(),2);
+
+        let bigram1 = vec!["<s>"];
+        let bigram2 = vec!["<s>", "a"];
+        let bigram3 = vec!["a"];
+        let bigram4 = vec!["a", "b"];
+        let bigram5 = vec!["b"];
+        let bigram6 = vec!["b", "c"];
+        let bigram7 = vec!["c"];
+        let bigram8 = vec!["c", "</s>"];
+        let bigram9 = vec!["</s>"];
+        let expected = vec![bigram1.iter(), bigram2.iter(), bigram3.iter(), bigram4.iter(), bigram5.iter(), bigram6.iter(),bigram7.iter(),bigram8.iter(),bigram9.iter()];
+
+        crate::test::should_be_equal_list_of_lists(&mut bigrams, expected)
+    }
+}
\ No newline at end of file
diff --git a/src/mat/bitmat.rs b/src/mat/bitmat.rs
new file mode 100644
index 0000000..33d208a
--- /dev/null
+++ b/src/mat/bitmat.rs
@@ -0,0 +1,84 @@
+use std::collections::BTreeMap;
+
+use crate::mat::{Mat, Numeric, Shape};
+
+// Mutable sparse matrix for boolean values
+// stored in u128
+struct SparseBitMat {
+    data: BTreeMap<usize, BTreeMap<usize, u128>>,
+}
+
+impl SparseBitMat {
+    fn new() -> Self {
+        Self {
+            data: BTreeMap::new()
+        }
+    }
+
+    pub fn set_true(&mut self, row_index: usize, col_index: usize) {
+        let d = self.get_byte(row_index, col_index);
+        *d |= 1 << (col_index % 128);
+    }
+
+    pub fn set_false(&mut self, row_index: usize, col_index: usize) {
+        let d = self.get_byte(row_index, col_index);
+        *d &= !(1 << (col_index % 128));
+    }
+
+    fn get_byte(&mut self, row_index: usize, col_index: usize) -> &mut u128 {
+        let row_index_b = row_index >> 7;
+        let col_index_b = col_index >> 7;
+        let mut row = self.data.entry(row_index_b).or_insert_with(BTreeMap::new);
+        let d = row.entry(col_index_b).or_insert(0_u128);
+        d
+    }
+
+
+}
+
+impl Mat<bool> for SparseBitMat {
+    fn get(&self, row_index: usize, col_index: usize) -> bool {
+        let row_index_b = row_index >> 7;
+        let col_index_b = col_index >> 7;
+        let row = self.data.get(&row_index_b);
+        if let Some(row) = row {
+            let d = row.get(&col_index_b);
+            if let Some(d) = d {
+                let bit = 1 << (col_index % 128);
+                return (*d & bit) != 0;
+            }
+        }
+        false
+    }
+
+    fn set(&mut self, row_index: usize, col_index: usize, value: bool) {
+        if value {
+            self.set_true(row_index, col_index);
+        } else {
+            self.set_false(row_index, col_index);
+        }
+    }
+
+
+    fn shape(&self) -> Shape {
+        todo!()
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use crate::mat::Mat;
+
+    #[test]
+    fn test_get_and_set() {
+        let mut mat = super::SparseBitMat::new();
+        mat.set(15, 15, true);
+        assert_eq!(mat.get(0, 0), false); //untouched
+        assert_eq!(mat.get(15, 15), true); //touched
+
+        mat.set(15, 15, false);
+        assert_eq!(mat.get(15, 15), false); //touched, set to false
+        mat.set(1001, 1001, false);
+        assert_eq!(mat.get(1001, 1001), false); //untouched, set to false
+    }
+}
\ No newline at end of file
diff --git a/src/mat/csr.rs b/src/mat/csr.rs
new file mode 100644
index 0000000..ca1c3ed
--- /dev/null
+++ b/src/mat/csr.rs
@@ -0,0 +1,113 @@
+use crate::mat::{Mat, Numeric, Shape};
+use crate::mat::sparse::SparseMat;
+
+/// Compressed Sparse Row matrix
+/// Immutable, can be constructed from Vec<Vec<T>>, or SparseMat<T>
+/// Better performance when iterating (i think), less memory
+pub struct CsrMat<T> where T: Numeric {
+    index_pointers: Vec<usize>,
+    indices: Vec<usize>,
+    data: Vec<T>,
+}
+
+impl<T> CsrMat<T> where T: Numeric {
+    pub fn new() -> Self {
+        Self {
+            index_pointers: Vec::new(),
+            indices: Vec::new(),
+            data: Vec::new(),
+        }
+    }
+}
+
+impl<T> Mat<T> for CsrMat<T> where T: Numeric {
+    fn get(&self, row: usize, column: usize) -> T {
+        if row + 2 > self.index_pointers.len() {
+            return Numeric::default::<T>();
+        }
+        let start_index = self.index_pointers[row];
+        let end_index = self.index_pointers[row + 1];
+
+        if start_index == end_index {
+            return Numeric::default::<T>();
+        } else {
+            let mut index = start_index;
+            while index < end_index && column != self.indices[index] {
+                index += 1;
+            }
+            if index == end_index {
+                return Numeric::default::<T>();
+            } else {
+                self.data[index]
+            }
+        }
+    }
+
+    fn set(&mut self, _row: usize, _column: usize, _value: T) {
+        panic!("Csr is immutable")
+    }
+
+    fn shape(&self) -> Shape {
+        Shape::new(self.index_pointers.len() - 1,
+                   self.indices.iter().map(|p| p + 1).max().unwrap_or(0))
+    }
+}
+
+impl<T> From<Vec<Vec<T>>> for CsrMat<T> where T: Numeric + PartialEq {
+    fn from(rows: Vec<Vec<T>>) -> Self {
+        let mut this = Self::new();
+
+        this.index_pointers.push(0);
+
+        for row in rows {
+            for (index, value) in row.into_iter().enumerate() {
+                if value != Numeric::default::<T>() {
+                    this.data.push(value);
+                    this.indices.push(index);
+                }
+            }
+            this.index_pointers.push(this.indices.len());
+        }
+        this
+    }
+}
+
+impl<T> From<Box<dyn Mat<T>>> for CsrMat<T> where T: Numeric + PartialEq {
+    fn from(this: Box<dyn Mat<T>>) -> Self {
+        let mut csr = Self::new();
+
+        csr.index_pointers.push(0);
+        let (rows, cols) = Shape::into(this.shape());
+        for row in 0..rows {
+            for col in 0..cols {
+                let value = this.get(row, col);
+                if value != Numeric::default::<T>() {
+                    csr.data.push(value);
+                    csr.indices.push(col);
+                }
+            }
+            csr.index_pointers.push(csr.indices.len());
+        }
+        csr
+    }
+}
+
+
+#[cfg(test)]
+mod test {
+    use crate::mat::{Mat, Shape};
+    use crate::mat::csr::CsrMat;
+    use crate::mat::sparse::SparseMat;
+
+    #[test]
+    fn test_from_mat() {
+        let mut mat: Box<dyn Mat<u32>> = Box::new(SparseMat::new());
+        mat.set(1, 1, 1_u32);
+        mat.set(2, 2, 2_u32);
+
+        let csr: CsrMat<u32> = mat.into();
+        assert_eq!(csr.get(1, 1), 1);
+        assert_eq!(csr.get(2, 2), 2);
+        assert_eq!(csr.shape(), Shape::new(3, 3));
+    }
+}
\ No newline at end of file
diff --git a/src/mat/mod.rs b/src/mat/mod.rs
new file mode 100644
index 0000000..a30bcec
--- /dev/null
+++ b/src/mat/mod.rs
@@ -0,0 +1,120 @@
+mod csr;
+mod sparse;
+mod bitmat;
+
+pub trait Mat<T: Numeric> {
+    fn get(&self, row_index: usize, col_index: usize) -> T;
+    fn set(&mut self, row_index: usize, col_index: usize, value: T);
+    fn shape(&self) -> Shape;
+}
+
+#[derive(PartialEq, Eq, Debug)]
+pub struct Shape {
+    rows: usize,
+    cols: usize,
+}
+
+impl Shape {
+    pub fn new(rows: usize, cols: usize) -> Self {
+        Self {
+            rows,
+            cols,
+        }
+    }
+}
+
+impl From<Shape> for (usize, usize){
+    fn from(this: Shape) -> Self {
+        (this.rows, this.cols)
+    }
+}
+
+pub trait Numeric: Copy + Default {
+    fn default<T>() -> Self;
+}
+
+impl Numeric for f64 {
+    fn default<T>() -> f64 { 0.0 }
+}
+
+impl Numeric for f32 {
+    fn default<T>() -> f32 { 0.0 }
+}
+
+impl Numeric for usize {
+    fn default<T>() -> usize { 0 }
+}
+
+impl Numeric for isize {
+    fn default<T>() -> isize { 0 }
+}
+
+impl Numeric for i8 {
+    fn default<T>() -> i8 { 0 }
+}
+
+impl Numeric for u8 {
+    fn default<T>() -> u8 { 0 }
+}
+
+impl Numeric for i16 {
+    fn default<T>() -> i16 { 0 }
+}
+
+impl Numeric for u16 {
+    fn default<T>() -> u16 { 0 }
+}
+
+impl Numeric for i32 {
+    fn default<T>() -> i32 { 0 }
+}
+
+impl Numeric for u32 {
+    fn default<T>() -> u32 { 0 }
+}
+
+impl Numeric for i64 {
+    fn default<T>() -> i64 { 0 }
+}
+
+impl Numeric for u64 {
+    fn default<T>() -> u64 { 0 }
+}
+
+impl Numeric for i128 {
+    fn default<T>() -> i128 { 0 }
+}
+
+impl Numeric for bool {
+    fn default<T>() -> Self {
+        false
+    }
+}
+
+impl Numeric for u128 {
+    fn default<T>() -> u128 { 0 }
+}
+
+#[cfg(test)]
+mod test {
+    use mat::csr::CsrMat;
+    use mat::Mat;
+
+    use crate::mat;
+
+    #[test]
+    fn test_i32() {
+        let rows = vec![vec![1, 0, 0, 0], vec![2]];
+        let new_mat = CsrMat::from(rows);
+        assert_eq!(2, new_mat.get(1, 0));
+        assert_eq!(0, new_mat.get(10, 0));
+    }
+
+    #[test]
+    fn test_f64() {
+        let rows = vec![vec![1.0, 0.0, 0.0, 0.0], vec![2.0]];
+        let new_mat = CsrMat::from(rows);
+        assert_eq!(2.0, new_mat.get(1, 0));
+        assert_eq!(0.0, new_mat.get(10, 0));
+    }
+}
\ No newline at end of file
diff --git a/src/mat/sparse.rs b/src/mat/sparse.rs
new file mode 100644
index 0000000..12271f0
--- /dev/null
+++ b/src/mat/sparse.rs
@@ -0,0 +1,64 @@
+use std::collections::BTreeMap;
+
+use crate::mat::{Mat, Numeric, Shape};
+
+/// BTreeMap based implementation, useful for mutating
+/// every row is a map<index, value> and the matrix is a map<index, map>
+/// resulting in a map<row_index<map<col_index,value>>
+/// uses a BTreeMap to keep the keys (indexes) ordered.
+pub struct SparseMat<T: Numeric> {
+    data: BTreeMap<usize, BTreeMap<usize, T>>,
+}
+
+impl<T: Numeric> SparseMat<T> {
+    pub fn new() -> Self {
+        Self {
+            data: BTreeMap::new()
+        }
+    }
+}
+
+impl<T: Numeric> Mat<T> for SparseMat<T> {
+    fn get(&self, row_index: usize, col_index: usize) -> T {
+        self.data.get(&row_index)
+            .map(|row| row.get(&col_index)
+                .map(|v|*v)
+                .unwrap_or(Numeric::default::<T>()))
+            .unwrap_or(Numeric::default::<T>())
+    }
+
+    fn set(&mut self, row_index: usize, col_index: usize, value: T) {
+        let row = self.data.entry(row_index).or_insert_with(BTreeMap::new);
+        row.insert(col_index, value);
+    }
+
+    fn shape(&self) -> Shape {
+        let mut max_rows = 0;
+        let mut max_cols = 0;
+        for row_index in self.data.keys() {
+            let row_index = *row_index;
+            if row_index > max_rows {
+                max_rows = row_index;
+            }
+            let row = self.data.get(&row_index).unwrap();
+            let last_col = *row.keys().max().unwrap();
+            if last_col > max_cols {
+                max_cols = last_col;
+            }
+        }
+        Shape::new(max_rows + 1, max_cols + 1)
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use crate::mat::{Mat, Shape};
+    use crate::mat::sparse::SparseMat;
+
+    #[test]
+    fn shape() {
+        let mut mat = SparseMat::new();
+        mat.set(10, 11, 1.5);
+        assert_eq!(mat.shape(), Shape::new(11, 12));
+    }
+}
diff --git a/src/metrics/distance.rs b/src/metrics/distance.rs
new file mode 100644
index 0000000..3f52bdb
--- /dev/null
+++ b/src/metrics/distance.rs
@@ -0,0 +1,50 @@
+// sandbox, to be removed
+
+use unicode_segmentation::UnicodeSegmentation;
+
+pub(crate) struct Element {
+    pub(crate) value: usize,
+}
+
+impl Element {
+    fn new() -> Self {
+        Self {
+            value: 0,
+        }
+    }
+}
+
+// non recursive implementation requires a table
+// my guess is that this is more efficient (should check)
+pub(crate) fn get_edit_distance_table(word1: &str, word2: &str) -> Vec<Vec<Element>> {
+    // create table
+    let mut table = Vec::new();
+    for _ in 0..=word1.len() {
+        let mut row = Vec::new();
+        for _ in 0..=word2.len() {
+            row.push(Element::new())
+        }
+        table.push(row);
+    }
+
+    // set the boundaries
+    for i in 0..=word1.len() {
+        table[i][0].value = i;
+    }
+    for i in 1..=word2.len() {
+        table[0][i].value = i;
+    }
+
+    for (i1, g1) in word1.graphemes(true).enumerate() {
+        for (i2, g2) in word2.graphemes(true).enumerate() {
+            let d_del = table[i1][i2 + 1].value + 1; //deletion
+            let d_ins = table[i1 + 1][i2].value + 1; //insertion
+            let d_sub = table[i1][i2].value + (if g1 == g2 { 0 } else { 2 }); // substitution
+            let min = usize::min(d_del, usize::min(d_ins, d_sub));
+            let element = table[i1 + 1].get_mut(i2 + 1).unwrap();
+            element.value = min;
+        }
+    }
+    table
+}
+
diff --git a/src/metrics/mod.rs b/src/metrics/mod.rs
new file mode 100644
index 0000000..39954c1
--- /dev/null
+++ b/src/metrics/mod.rs
@@ -0,0 +1,40 @@
+pub mod distance;
+
+/// Calculate the Levenshtein edit-distance between two strings.
+/// The edit distance is the number of characters that need to be substituted, inserted, or deleted, to transform s1 into s2.
+/// For example, transforming “rain” to “shine” requires three steps, consisting of two substitutions and one insertion:
+/// “rain” -> “sain” -> “shin” -> “shine”.
+/// These operations could have been done in other orders, but at least three steps are needed.
+///
+/// substitution cost is (for now at least) hardcoded as 2
+pub fn edit_distance(s1: &str, s2: &str) -> usize {
+    distance::get_edit_distance_table(s1, s2)[s1.len()][s2.len()].value
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_levenshtein_distance() {
+        assert_eq!(edit_distance("intention", "execution"), 8);
+    }
+
+    #[test]
+    fn test_get_edit_distance_table() {
+        // example from Stanford NLP course: https://youtu.be/kgcEaoM_QJA
+        let word1 = "intention";
+        let word2 = "execution";
+
+        let outcome: [[usize; 10]; 10] = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 6, 7, 8], [2, 3, 4, 5, 6, 7, 8, 7, 8, 7], [3, 4, 5, 6, 7, 8, 7, 8, 9, 8], [4, 3, 4, 5, 6, 7, 8, 9, 10, 9],
+            [5, 4, 5, 6, 7, 8, 9, 10, 11, 10], [6, 5, 6, 7, 8, 9, 8, 9, 10, 11], [7, 6, 7, 8, 9, 10, 9, 8, 9, 10], [8, 7, 8, 9, 10, 11, 10, 9, 8, 9], [9, 8, 9, 10, 11, 12, 11, 10, 9, 8]];
+
+        let tab = distance::get_edit_distance_table(word1, word2);
+
+        for (rowindex, row) in tab.iter().enumerate() {
+            for (colindex, element) in row.iter().enumerate() {
+                assert_eq!(outcome[rowindex][colindex], element.value);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/pipelines.rs b/src/pipelines.rs
new file mode 100644
index 0000000..ceb7d70
--- /dev/null
+++ b/src/pipelines.rs
@@ -0,0 +1,29 @@
+use std::collections::BTreeMap;
+use std::collections::hash_map::DefaultHasher;
+use std::fs::File;
+use std::hash::{Hash, Hasher};
+use std::io::{self, BufRead};
+
+pub fn count() -> anyhow::Result<()> {
+    let mut store: BTreeMap<String, usize> = BTreeMap::new();
+    let stdin = io::stdin();
+    for line in stdin.lock().lines() {
+        let line = line?;
+        for token in line.split(|c: char| c.is_ascii_punctuation() || c.is_whitespace()) {
+            let count = store.entry(token.to_owned()).or_insert(0);
+            *count += 1;
+        }
+    }
+    for (key, value) in store{
+        println!("{}:{}", key,value);
+    }
+    Ok(())
+}
+
+fn hash(string: &str) -> u64 {
+    let mut hasher = DefaultHasher::new();
+    string.hash(&mut hasher);
+    hasher.finish()
+}
+
+pub fn create_binary_bow(file: File) {}
\ No newline at end of file
diff --git a/src/substitute.rs b/src/substitute.rs
deleted file mode 100644
index 8ca4028..0000000
--- a/src/substitute.rs
+++ /dev/null
@@ -1,129 +0,0 @@
-#![warn(clippy::all, clippy::pedantic)]
-
-use std::{env, io, process, thread};
-use std::collections::HashMap;
-use std::fs::File;
-use std::hash::Hash;
-use std::io::BufRead;
-use chrono::{DateTime, Local};
-use crossbeam_channel::bounded;
-use lazy_static::lazy_static;
-use unicode_segmentation::UnicodeSegmentation;
-
-use crate::worker::ThreadPool;
-
-mod worker;
-
-const BUFFER_SIZE: usize = 10_000;
-
-fn main() -> Result<(), io::Error> {
-    let args: Vec<String> = env::args().collect();
-    if args.len() < 2 {
-        eprintln!("Usage: clean [whitelist-filename] input-filename");
-        process::exit(-1);
-    }
-
-    let input_filename = if args.len() == 3 {
-        &args[2]
-    } else {
-        &args[1]
-    };
-
-    let start: DateTime<Local> = Local::now();
-
-    let file = File::open(input_filename)?;
-    let reader = io::BufReader::new(file);
-
-    let mut worker_pool = ThreadPool::new(4); // TODO turn into cmdline argument
-    let (merge_sender, merge_receiver) = bounded::<Option<Vec<String>>>(8);
-
-    {
-        thread::spawn(move || {
-            loop {
-                // handle Error case silently
-                let maybe_buffer = merge_receiver.recv().unwrap_or(None);
-                if let Some(clean_buffer) = maybe_buffer {
-                    for line in clean_buffer {
-                        println!("{}", line);
-                    }
-                } else {
-                    // None is the break signal (may be made nicer using enum)
-                    break;
-                }
-            }
-        });
-    }
-
-    let mut line_count = 0usize;
-    let mut buffer = Vec::with_capacity(BUFFER_SIZE);
-    for line in reader.lines().flatten() {
-        if line_count < BUFFER_SIZE {
-            buffer.push(line);
-            line_count += 1;
-        } else {
-            // multi producer, single consumer. So multiple senders, using clone
-            let merge_sender = merge_sender.clone();
-            worker_pool.execute(move || handle_line_buffer(buffer, &merge_sender));
-            buffer = Vec::with_capacity(BUFFER_SIZE);
-            line_count = 0;
-        }
-    }
-    // last, partially filled buffer
-    worker_pool.execute(move || handle_line_buffer(buffer, &merge_sender));
-
-    worker_pool.wait();
-
-    eprintln!("took {} seconds", Local::now().signed_duration_since(start));
-    Ok(())
-}
-
-fn handle_line_buffer(buffer: Vec<String>, sender: &crossbeam_channel::Sender<Option<Vec<String>>>) {
-    lazy_static! {
-        static ref args: Vec<String> = env::args().collect();
-        static ref SUBST:HashMap<String, String> = if args.len() == 3 {
-            let whitelist_filename = &args[1];
-                read_whitelist(whitelist_filename).unwrap()
-            } else {
-                read_std_whitelist().unwrap()
-        };
-        static ref WHITELIST:HashMap<&'static str, &'static str> = SUBST.iter().map(|(s,t)| (s.as_str(),t.as_str())).collect::<HashMap<&'static str, &'static str>>();
-    }
-    let mut clean_buffer = vec![];
-    for line in buffer {
-        let mut clean_line = String::new();
-        line.graphemes(true).map(|g|*(SUBST.get(g)).or_else(||Some(g.to_owned()))).for_each(|c| clean_line.push_str(c.unwrap()));
-        clean_buffer.push(clean_line);
-    }
-
-    sender.send(Some(clean_buffer)).unwrap();
-}
-
-fn read_whitelist(filename: &String) -> Result<HashMap<String, String>, io::Error> {
-    let file = File::open(filename)?;
-    let reader = io::BufReader::new(file);
-    let mut substitutions = HashMap::new();
-
-    for line in reader.lines().flatten() {
-        let key_value = line.split(":").map(|e|e.to_owned()).collect::<Vec<String>>();
-        let source = key_value[0].clone();
-        let dest = key_value[1].clone();
-        source.graphemes(true).for_each(|token| { substitutions.insert(token.to_owned(), dest.clone()); });
-    }
-
-    Ok(substitutions)
-}
-
-fn read_std_whitelist() -> Result<HashMap<String, String>, io::Error> {
-    let substitute_dat = include_str!("default_substitute.dat");
-
-    let mut substitutions = HashMap::new();
-
-    for line in substitute_dat.split("\n") {
-        let key_value = line.split(":").map(|e|e.to_owned()).collect::<Vec<String>>();
-        let source = key_value[0].clone();
-        let dest = key_value[1].clone();
-        source.graphemes(true).for_each(|token| { substitutions.insert(token.to_owned(), dest.clone()); });
-    }
-
-    Ok(substitutions)
-}
\ No newline at end of file
diff --git a/src/test.rs b/src/test.rs
new file mode 100644
index 0000000..1ec2bda
--- /dev/null
+++ b/src/test.rs
@@ -0,0 +1,26 @@
+use std::slice::Iter;
+
+pub fn should_be_equal_lists<'a>(left: impl Iterator<Item=&'a &'a str>, right: &[&'a str]) {
+    for (left, right) in left.zip(right.into_iter()) {
+        assert_eq!(left, right);
+    }
+}
+
+pub fn should_be_equal_list_of_lists<'a>(actual: &mut impl Iterator<Item=impl Iterator<Item=&'a &'a str>>, expected: Vec<Iter<&'a str>>) {
+    let actual = collect(actual);
+    assert_eq!(actual.len(), expected.len());
+    for (actual_outer, expected_outer) in actual.into_iter().zip(expected.into_iter()) {
+        let actual_outer: Vec<&&str> = actual_outer.collect();
+        let expected_outer: Vec<&&str> = expected_outer.collect();
+        assert_eq!(actual_outer.len(), expected_outer.len());
+        for (actual_inner, expected_inner) in actual_outer.iter().zip(expected_outer.iter()) {
+            assert_eq!(actual_inner, expected_inner);
+        }
+    }
+}
+
+fn collect<'a>(iter: &mut impl Iterator<Item=impl Iterator<Item=&'a &'a str>>) -> Vec<impl Iterator<Item=&'a &'a str>> {
+    let mut vec = Vec::new();
+    vec.extend(iter);
+    vec
+}
\ No newline at end of file
diff --git a/src/util/mod.rs b/src/util/mod.rs
new file mode 100644
index 0000000..dbe54e5
--- /dev/null
+++ b/src/util/mod.rs
@@ -0,0 +1,212 @@
+pub(crate) mod padding;
+pub(crate) mod ngrams;
+
+use padding::Padder;
+
+/// Returns a padded sequence of items before ngram extraction.
+///
+/// sequence: sequence of items to pad, in the form of an Iterator of string slices.
+/// pad_left: if set to true, prepends a padding symbol to the sentence
+/// left_pad_symbol: the padding symbol to prepend
+/// pad_right: if set to true, appends a padding symbol after the sentence
+/// right_pad_symbol: the padding symbol to append
+/// n: the n in n-grams; so for bigrams set to 2, etc
+pub fn pad_sequence<'a>(sentence: impl Iterator<Item=&'a &'a str> + 'a, pad_left: bool, left_pad_symbol: &'a &'a str, pad_right: bool, right_pad_symbol: &'a &'a str, n: usize) -> impl Iterator<Item=&'a &'a str> {
+    Padder::new(Box::new(sentence), pad_left, left_pad_symbol, pad_right, right_pad_symbol, n)
+}
+
+/// Returns a padded sequence of items before ngram extraction, left-padding only. Convenience function that prevents useless arguments
+/// sequence: sequence of items to pad, in the form of an Iterator of string slices.
+/// left_pad_symbol: the padding symbol to prepend
+/// n: the n in n-grams; so for bigrams set to 2, etc
+pub fn pad_sequence_left<'a>(sequence: impl Iterator<Item=&'a &'a str> + 'a, left_pad_symbol: &'a &'a str, n: usize) -> impl Iterator<Item=&'a &'a str> {
+    Padder::new(Box::new(sequence), true, left_pad_symbol, false, &"", n)
+}
+
+/// Returns a padded sequence of items before ngram extraction, right-padding only. Convenience function that prevents useless arguments
+///
+/// sequence: sequence of items to pad, in the form of an Iterator of string slices.
+/// pad_right: if set to true, appends a padding symbol after the sentence
+/// right_pad_symbol: the padding symbol to append
+/// n: the n in n-grams; so for bigrams set to 2, etc
+pub fn pad_sequence_right<'a>(sequence: impl Iterator<Item=&'a &'a str> + 'a, right_pad_symbol: &'a &'a str, n: usize) -> impl Iterator<Item=&'a &'a str>  {
+    Padder::new(Box::new(sequence), false, &"", true, right_pad_symbol, n)
+}
+
+/// Return the ngrams generated from a sequence of items, as an iterator.
+///
+/// sequence: the sequence items in the form of an Iterator over &&str
+/// use like:
+/// ```
+/// let sequence = vec!["a", "b", "c"];
+/// let mut bigrams = rltk::util::ngrams(sequence.iter(), 2);
+///
+/// let bigram1 = vec!["a", "b"];
+/// let bigram2 = vec!["b", "c"];
+/// let expected = vec![bigram1.iter(), bigram2.iter()];
+///
+/// for (mut left_outer,mut right_outer) in bigrams.zip(expected.into_iter()){
+///     for (left_inner,right_inner) in left_outer.zip(right_outer){
+///         assert_eq!(left_inner, right_inner);
+///     }
+/// }
+/// ```
+///
+pub fn ngrams<'a>(sequence: impl Iterator<Item=&'a &'a str> + 'a, n: usize) -> impl Iterator<Item=impl Iterator<Item=&'a &'a str> + 'a> {
+    ngrams::NGramSequenceIter::new(sequence, n)
+}
+
+pub fn bigrams<'a>(sequence: impl Iterator<Item=&'a &'a str> + 'a) -> impl Iterator<Item=impl Iterator<Item=&'a &'a str> + 'a>  {
+    ngrams::NGramSequenceIter::new(sequence, 2)
+}
+
+pub fn trigrams<'a>(sequence: impl Iterator<Item=&'a &'a str> + 'a) -> impl Iterator<Item=impl Iterator<Item=&'a &'a str> + 'a>  {
+    ngrams::NGramSequenceIter::new(sequence, 3)
+}
+
+pub fn everygrams<'a>(sequence: impl Iterator<Item=&'a &'a str> + 'a, n: usize) -> impl Iterator<Item=Box<dyn Iterator<Item=&'a &'a str> + 'a>> {
+    ngrams::EveryGramSequenceIter::everygrams(sequence, n)
+}
+
+pub fn flatten<'a>(ngrams: impl Iterator<Item=Box<dyn Iterator<Item=&'a &'a str> + 'a>> + 'a) -> impl Iterator<Item=&'a &'a str> {
+    ngrams::FlatteningIter::new(ngrams)
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::test::*;
+
+    #[test]
+    fn test_pad_both_ends_default_n2() {
+        let text = ["a", "b", "c"];
+        let padded = pad_sequence(text.iter(), true, &"<s>", true, &"</s>", 2);
+        should_be_equal_lists(padded, &["<s>", "a", "b", "c", "</s>"]);
+    }
+
+    #[test]
+    fn test_pad_left() {
+        let text = ["a", "b", "c"];
+        let padded = pad_sequence_left(text.iter(), &"<s>", 2);
+        should_be_equal_lists(padded, &["<s>", "a", "b", "c"]);
+    }
+
+    #[test]
+    fn test_pad_right() {
+        let text = ["a", "b", "c"];
+        let padded = pad_sequence_right(text.iter(), &"</s>", 2);
+
+        should_be_equal_lists(padded, &["a", "b", "c", "</s>"]);
+    }
+
+    #[test]
+    fn test_pad_both_ends_default_n_eq_3() {
+        let text = ["a", "b", "c"];
+        let padded = pad_sequence(text.iter(), true, &"<s>", true, &"</s>", 3);
+        should_be_equal_lists(padded, &["<s>", "<s>", "a", "b", "c", "</s>", "</s>"]);
+    }
+
+    #[test]
+    fn test_pad_both_ends_non_default_symbols() {
+        let text = ["a", "b", "c"];
+        let padded = pad_sequence(text.iter(), true, &"left", true, &"right", 2);
+
+        should_be_equal_lists(padded, &["left", "a", "b", "c", "right"]);
+    }
+
+    #[test]
+    fn test_bigrams() {
+        let sequence = ["a", "b", "c", "d"];
+        let mut bigrams = ngrams(sequence.iter(), 2);
+        let bigram1 = vec!["a", "b"];
+        let bigram2 = vec!["b", "c"];
+        let bigram3 = vec!["c", "d"];
+        let expected = vec![bigram1.iter(), bigram2.iter(), bigram3.iter()];
+
+        should_be_equal_list_of_lists(&mut bigrams, expected)
+    }
+
+    #[test]
+    fn test_trigrams() {
+        let sequence = ["a", "b", "c", "d", "e"];
+        let mut bigrams = ngrams(sequence.iter(), 3);
+        let trigram1 = vec!["a", "b", "c"];
+        let trigram2 = vec!["b", "c", "d"];
+        let trigram3 = vec!["c", "d", "e"];
+        let expected = vec![trigram1.iter(), trigram2.iter(), trigram3.iter()];
+
+        should_be_equal_list_of_lists(&mut bigrams, expected)
+    }
+
+    #[test]
+    fn test_bigrams_n_gt_len() {
+        let sequence = ["a"];
+        let mut bigrams = ngrams(sequence.iter(), 2);
+        assert!(bigrams.next().is_none());
+    }
+
+    #[test]
+    fn test_bigrams_empty_sequence() {
+        let sequence: Vec<&str> = vec![];
+        let mut bigrams = ngrams(sequence.iter(), 10);
+        assert!(bigrams.next().is_none());
+    }
+
+    #[test]
+    fn test_bigrams_n_eq_len() {
+        let sequence = ["a", "b"];
+        let mut bigrams = ngrams(sequence.iter(), 2);
+        let bigram1 = vec!["a", "b"];
+        let expected = vec![bigram1.iter()];
+
+        should_be_equal_list_of_lists(&mut bigrams, expected);
+    }
+
+
+    #[test]
+    fn test_everygrams_n_eq_2() {
+        let sequence = ["a", "b", "c", "d"];
+        let mut grams = everygrams(sequence.iter(), 2);
+        let gram1 = ["a"];
+        let gram2 = ["a", "b"];
+        let gram3 = ["b"];
+        let gram4 = ["b", "c"];
+        let gram5 = ["c"];
+        let gram6 = ["c", "d"];
+        let gram7 = ["d"];
+        let expected = vec![gram1.iter(), gram2.iter(), gram3.iter(), gram4.iter(), gram5.iter(), gram6.iter(), gram7.iter()];
+
+        should_be_equal_list_of_lists(&mut grams, expected);
+    }
+
+    #[test]
+    fn test_everygrams_n_eq_3() {
+        let sequence = ["a", "b", "c", "d", "e"];
+        let mut bigrams = everygrams(sequence.iter(), 3);
+
+        let gram1 = ["a"];
+        let gram2 = ["a", "b"];
+        let gram3 = ["a", "b", "c"];
+        let gram4 = ["b"];
+        let gram5 = ["b", "c"];
+        let gram6 = ["b", "c", "d"];
+        let gram7 = ["c"];
+        let gram8 = ["c", "d"];
+        let gram9 = ["c", "d", "e"];
+        let gram10 = ["d"];
+        let gram11 = ["d", "e"];
+        let gram12 = ["e"];
+
+        let expected = vec![gram1.iter(), gram2.iter(), gram3.iter(), gram4.iter(), gram5.iter(), gram6.iter(), gram7.iter(), gram8.iter(), gram9.iter(), gram10.iter(), gram11.iter(), gram12.iter()];
+
+        should_be_equal_list_of_lists(&mut bigrams, expected);
+    }
+
+    #[test]
+    fn test_flatten() {
+        let sequence = ["a", "b", "c", "d", "e"];
+        let expected = ["a", "a", "b", "a", "b", "c", "b", "b", "c", "b", "c", "d", "c", "c", "d", "c", "d", "e"];
+
+        should_be_equal_lists(flatten(everygrams(sequence.iter(), 3)), &expected);
+    }
+}
\ No newline at end of file
diff --git a/src/util/ngrams.rs b/src/util/ngrams.rs
new file mode 100644
index 0000000..4720ed6
--- /dev/null
+++ b/src/util/ngrams.rs
@@ -0,0 +1,135 @@
+pub struct NGramSequenceIter<'a> {
+    sequence: Box<dyn Iterator<Item=&'a &'a str> + 'a>,
+    n: usize,
+    current_ngram: Vec<&'a &'a str>,
+}
+
+impl<'a> NGramSequenceIter<'a> {
+    pub(crate) fn new(sequence: impl Iterator<Item=&'a &'a str> + 'a, n: usize) -> Self {
+        Self {
+            sequence: Box::new(sequence),
+            n,
+            current_ngram: Vec::new(),
+        }
+    }
+}
+
+impl<'a> Iterator for NGramSequenceIter<'a> {
+    type Item = Box<dyn Iterator<Item=&'a &'a str> + 'a>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        return if self.current_ngram.len() == 0 {
+            for _ in 0..self.n {
+                if let Some(item) = self.sequence.next() {
+                    self.current_ngram.push(item);
+                } else {
+                    return None; // n > len
+                }
+            }
+
+            Some(Box::new(self.current_ngram.clone().into_iter()))
+        } else {
+            self.current_ngram.remove(0);
+            let maybe_next = self.sequence.next();
+            if maybe_next.is_some() {
+                self.current_ngram.push(&maybe_next.unwrap());
+                Some(Box::new(self.current_ngram.clone().into_iter()))
+            } else {
+                None
+            }
+        };
+    }
+}
+
+pub struct EveryGramSequenceIter<'a> {
+    sequence: Box<dyn Iterator<Item=&'a &'a str> + 'a>,
+    max_order: usize,
+    current_ngram: Vec<&'a &'a str>,
+    current_order: usize,
+}
+
+impl<'a> EveryGramSequenceIter<'a> {
+    pub(crate) fn everygrams(sequence: impl Iterator<Item=&'a &'a str> + 'a, max_order: usize) -> Self {
+        Self {
+            sequence: Box::new(sequence),
+            max_order,
+            current_ngram: Vec::new(),
+            current_order: 0,
+        }
+    }
+}
+
+impl<'a> Iterator for EveryGramSequenceIter<'a> {
+    type Item = Box<dyn Iterator<Item=&'a &'a str> + 'a>;
+
+    //noinspection DuplicatedCode, hard to deduplicate because of early return
+    fn next(&mut self) -> Option<Self::Item> {
+        // initiate a temp buffer (current_ngram) from which
+        if self.current_ngram.len() == 0 {
+            for _ in 0..self.max_order {
+                if let Some(item) = self.sequence.next() {
+                    self.current_ngram.push(item);
+                } else {
+                    return None; // n > len
+                }
+            }
+        }
+
+        self.current_order += 1;
+
+        // slide window to the right in the sentence, if all ngrams of desired max order have been iterated
+        // and accomodate for end of sentence
+        if self.current_order > self.max_order { // last item of current ngram reached
+            self.current_order = 1; // start again with 1
+            self.current_ngram.remove(0); // first item is not part of any coming ngrams, and can be removed
+            let maybe_next = self.sequence.next(); // next item in source
+            if maybe_next.is_some() {
+                self.current_ngram.push(&maybe_next.unwrap());
+            } else {
+                self.max_order -= 1; // the desired max ngram length gets shorter at the end where there are no more new items in the iterator
+                // theoretically it would be better if we do not mutate max_order and a use a new variable "desired_max_order" oder so etwas.
+                if self.current_ngram.len() == 0 { // all items have been removed and no new have been added, we're at the end
+                    return None;
+                }
+            }
+        }
+        // take n items from the ngram where n (current_order) is incremented (unigram, bigram, trigram etc)
+        return Some(Box::new(self.current_ngram.clone().into_iter().take(self.current_order)));
+    }
+}
+
+/// like flatmap fn
+pub struct FlatteningIter<'a> {
+    list_of_lists: Box<dyn Iterator<Item=Box<dyn Iterator<Item=&'a &'a str> + 'a>> + 'a>,
+    current: Option<Box<dyn Iterator<Item=&'a &'a str> + 'a>>,
+}
+
+impl<'a> FlatteningIter<'a> {
+    pub(crate) fn new(ngrams: impl Iterator<Item=Box<dyn Iterator<Item=&'a &'a str> + 'a>> + 'a) -> Self {
+        Self {
+            list_of_lists: Box::new(ngrams),
+            current: None,
+        }
+    }
+}
+
+impl<'a> Iterator for FlatteningIter<'a> {
+    type Item = &'a &'a str;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        if self.current.is_none() {
+            self.current = self.list_of_lists.next();
+        }
+
+        while let Some(ref mut current_ngram) = self.current {
+            let current_item = current_ngram.next();
+            if current_item.is_some() {
+                return current_item;
+            } else {
+                self.current = self.list_of_lists.next();
+            }
+        }
+
+        None
+    }
+}
\ No newline at end of file
diff --git a/src/util/padding.rs b/src/util/padding.rs
new file mode 100644
index 0000000..6311629
--- /dev/null
+++ b/src/util/padding.rs
@@ -0,0 +1,40 @@
+pub struct Padder<'a> {
+    n: usize,
+    text: Box<dyn Iterator<Item=&'a &'a str> + 'a>,
+    pad_left: bool,
+    left_index: isize,
+    left_pad_symbol: &'a &'a str,
+    pad_right: bool,
+    right_index: isize,
+    right_pad_symbol: &'a &'a str,
+}
+
+impl<'a> Iterator for Padder<'a> {
+    type Item = &'a &'a str;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        if self.pad_left && self.left_index < self.n as isize {
+            self.left_index += 1;
+            return Some(self.left_pad_symbol);
+        } else {
+            let maybe_next = self.text.next();
+            if maybe_next.is_some() {
+                return maybe_next;
+            } else {
+                if self.pad_right && self.right_index < self.n as isize {
+                    self.right_index += 1;
+                    return Some(self.right_pad_symbol);
+                }
+            }
+        }
+
+        None
+    }
+}
+
+impl<'a> Padder<'a> {
+    pub(crate) fn new(text: Box<dyn Iterator<Item=&'a &'a str> + 'a>, pad_left: bool, left_pad_symbol:&'a &'a str,
+                      pad_right: bool, right_pad_symbol: &'a &'a str, n: usize, ) -> Self {
+        Self { text, n, pad_left, left_index: 1, left_pad_symbol, pad_right, right_index: 1, right_pad_symbol }
+    }
+}
diff --git a/src/worker.rs b/src/worker.rs
deleted file mode 100644
index c259428..0000000
--- a/src/worker.rs
+++ /dev/null
@@ -1,95 +0,0 @@
-use std::sync::{Arc, Mutex};
-use std::thread;
-use std::time::Duration;
-
-// custom threadpool implementation
-// may be replaced by crate, if I find the right one. Have looked at crossbeam and rayon.
-// Rayon par_iter for instance doesn't seem usable, because it lacks buffering, which I guess would increase context switching
-// this is in principle an uncorroborated thought
-// It does use crossbeam_channel::bounded, which is crucial to avoid memory overload (more than 30 Gbs instead of at most ~3 in the current implementation)
-enum Message {
-    NewJob(Job),
-    Terminate,
-}
-
-pub struct ThreadPool {
-    workers: Vec<Worker>,
-    sender: crossbeam_channel::Sender<Message>,
-}
-
-type Job = Box<dyn FnOnce() + Send + 'static>;
-
-impl ThreadPool {
-    /// Create a new threadpool
-    /// size: the number of threads in the pool
-    /// # Panics
-    #[must_use = "size must be >0"]
-    pub fn new(size: usize) -> Self {
-        assert!(size > 0);
-
-        // The max number of messages in the channel should be higher as the number of workerthreads grows
-        // to avoid idle threads.
-        let (sender, receiver) = crossbeam_channel::bounded(size * 2); // just a stab
-        let receiver = Arc::new(Mutex::new(receiver));
-        let mut workers = Vec::with_capacity(size);
-
-        for _ in 0..size {
-            workers.push(Worker::new(Arc::clone(&receiver)));
-        }
-
-        Self {
-            workers,
-            sender,
-        }
-    }
-
-    /// submit a function for multithreaded processing
-    pub fn execute<F>(&self, f: F) where F: FnOnce() + Send + 'static {
-        let job = Box::new(f);
-
-        self.sender.send(Message::NewJob(job)).unwrap();
-    }
-
-    /// wait for workerthreads to finish
-    pub fn wait(&mut self) {
-        for worker in &mut self.workers {
-            self.sender.send(Message::Terminate).unwrap_or(());
-            if let Some(thread) = worker.thread.take() {
-                thread.join().unwrap();
-            }
-        }
-    }
-}
-
-struct Worker {
-    thread: Option<thread::JoinHandle<()>>,
-}
-
-impl Worker {
-    fn new(receiver: Arc<Mutex<crossbeam_channel::Receiver<Message>>>) -> Self {
-        let thread = thread::spawn(move || {
-            loop {
-                // idle worker threads die quickly, so avoid this situation
-                // the timeout can be increased if that is not what you want
-                // For small workloads the timeout is necessary, because some theads may never get the Terminate command and thus prevent the process from ending.
-                let message_r = receiver.lock().unwrap().recv_timeout(Duration::from_secs(1));
-                if let Ok(message) = message_r {
-                    match message {
-                        Message::NewJob(job) => {
-                            job();
-                        }
-                        Message::Terminate => {
-                            break;
-                        }
-                    }
-                } else {
-                    break;
-                }
-            }
-        });
-
-        Self {
-            thread: Some(thread),
-        }
-    }
-}
\ No newline at end of file
